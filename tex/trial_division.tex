\subsubsection{素朴な実装}
\label{sssec:trial_division_simple}
素数の見つけ方(あるいは合成数であることの確かめ方)の最も素朴なものが\IND{試し割}{ためしわり}(trial division)であろう。
$n$が与えられたとき、$2$以上$n$未満のすべての正整数で手あたり次第割ってみるのだ。
素数ならばこれらのどんな数でも割り切ることはできないし、反対に合成数ならば割り切れる数が存在する。
最も原始的な方法とも呼べるが、大抵の場合、試し割で事足りるし、アルゴリズム自体も単純であるため高速に実行できる。
まったく前情報のない整数$n$があって、素因数分解をする必要がなったならば、試し割を実行してみるとよいだろう。
そこで素因数を発見できれば万々歳だし、そうでなければ本腰を入れて別のアルゴリズムを適用するということになる。
しかるに、他のアルゴリズムを適用するにしても、前処理として重要である。

すぐに分かることであるが、試し割るにしても$n-1$まで実施する必要はない。
例えば、$11$が素数であるかを判定するために、$10$で割ってみる必要はなく$3$まででよい。
一般に、$n$に対して$\sqrt{n}$まで試し割ればよいことが知られている。
なぜかというと、$n$の素因数が存在するならば少なくとも1つは$\sqrt{n}$以下に存在するからだ。
もし合成数$n=ab$について、$a,b$両方とも$\sqrt{n}$より大きいと、積$ab$は$n$より大きくなり矛盾する。

\Algo{試し割}{trial_division}{c.f., \rAlgo{sqrt_int}}

\subsubsection{実装上の補足}
アルゴリズム中で使用するサブ関数として、平方根の整数部を求めるアルゴリズムを紹介する。
平方根程度、標準ライブラリに任せておいても良いのだが、この界隈で扱う数字は往々にして浮動小数で扱える範囲を超えてしまう。
ここで紹介するアルゴリズムは、\IND{Newton法}{Newtonほう}と呼ばれるものである。
Newton法は方程式の求根アルゴリズムの一種であるが、応用として平方根を求めるためにも使える。

動作を追うと分かるが、$x$は徐々に減少し、$\left \lfloor\sqrt{n}\right \rfloor$に達すると終了する。
なので、$x$の初期値は$\left \lfloor\sqrt{n}\right \rfloor$以上なら何でも良いのだが、$x$が大きいとループ回数が増える。
初期値が$n$のとき$O(\log{n})$、初期値が$2^{\left \lceil b/2 \right \rceil}$のとき$O(\log\log{n})$であるから後者の方が有利だ(ここで$b$は$n$の2進長)。

\Algo{平方根}{sqrt_int}{}

同じようにして、$n$乗根を求めるアルゴリズムも載せておく。

\Algo{$n$乗根}{nth_root_int}

分かっている人にとっては当たり前のことだが、$n$乗根が簡単に見つけられるということは、累乗数の素因数分解が簡単ということでもある。$n$が$m^k$のような形をしているかは\rAlgo{nth_root_int}を使って確認できる。
しかも、$k$は高々$\log_2{n}$であり、すべて調べても大したことはないが、少し考えれば素数冪のみを調べれば十分であることが分かる。
例えば、$n$が$m^{10}$という形で書けるかは、$m^2$あるいは$m^5$となるかどうかだけを調べれば事足りるので実施する必要はない。

\Algo{累乗数判定}{is_perfect_power}{c.f., \rAlgo{nth_root_int}}

更なる高速化に向けて、既に2で割り切るか試したのに、4や10で割り切るかを調べる必要はない。
高速化の手法として、割る数を自然数ではなく、素数に限定するということは考えられるが、一方で素数を列挙するコストもあるため、ケースバイケースで対応した方がよいだろう。
そうでないにしても、2以外は奇数のみで試し割をするなどの工夫の余地はある。
試し割とはあまり面白みがないアルゴリズムだと、がっかりするかもしれないが、ともかく素数に関する最初のアルゴリズムを得たわけだ。

