\subsubsection{素朴な実装}
素数の見つけ方(あるいは合成数であることの確かめ方)の最も素朴なものが\IND{試し割}{ためしわり}(trial division)であろう。
$n$が与えられたとき、$2$以上$n$未満のすべての正整数で手あたり次第割ってみるのだ。
素数ならばこれらのどんな数でも割り切ることはできないし、反対に合成数ならば割り切れる数が存在する。
最も原始的な方法とも呼べるが、大抵の場合、試し割で事足りるし、アルゴリズム自体も単純であるため高速に実行できる。
まったく前情報のない整数$n$があって、素因数分解をする必要がなったならば、試し割を実行してみるとよいだろう。
そこで素因数を発見できれば万々歳だし、そうでなければ本腰を入れて別のアルゴリズムを適用するということになる。
しかるに、他のアルゴリズムを適用するにしても、前処理として重要である。

すぐに分かることであるが、試し割るにしても$n-1$まで実施する必要はない。
例えば、$11$が素数であるかを判定するために、$10$で割ってみる必要はなく$3$まででよい。
一般に、$n$に対して$\sqrt{n}$まで試し割ればよいことが知られている。
なぜかというと、$n$の素因数が存在するならば少なくとも1つは$\sqrt{n}$以下に存在するからだ。
もし合成数$n=ab$について、$a,b$両方とも$\sqrt{n}$より大きいと、積$ab$は$n$より大きくなり矛盾する。

\Algo{試し割}{trial_division}{c.f., \rAlgo{sqrt_int}}

\subsubsection{実装上の補足}
アルゴリズム中で使用するサブ関数として、平方根の整数部を求めるアルゴリズムを紹介する。
平方根程度、標準ライブラリに任せておいても良いのだが、この界隈で扱う数字は往々にして浮動小数で扱える範囲を超えてしまう。
ここで紹介するアルゴリズムは、\IND{Newton法}{Newtonほう}と呼ばれるものである。
Newton法は方程式の求根アルゴリズムの一種であるが、応用として平方根を求めるためにも使える。

実行してみると分かるが、変数$x$は1回のループで約$1/2$倍になっている。
つまり、$k$回目のループ終了後$x$は約$n/2^k$となるわけであるが、それが$\sqrt{n}=n/\sqrt{n}$に達するまでのループ回数は$\lg\sqrt{n}$と見積もれる。
よって、計算量としては$O(\log{n})$となる。

\Algo{平方根}{sqrt_int}{}

同じようにして、$n$乗根を求めるアルゴリズムも載せておく。

\Algo{$n$乗根}{nth_root_int}

分かっている人にとっては当たり前のことだが、$n$乗根が簡単に見つけられるということは、累乗数の素因数分解が簡単ということでもある。
与えられた$n$が$m^2$のような形をしているかは、$n$の平方根の整数部分を2乗して$n$に一致しているかを確認すればよいし、そうであるならば$n$の平方根が非自明な因数である。
同様に、$n$が$m^k$のような形をしているかも\rAlgo{nth_root_int}を使って確認できる。
しかも、$k$は高々$\log_2{n}$であり、すべて調べることは難しくない。

\Algo{累乗数判定}{is_perfect_power}{c.f., \rAlgo{nth_root_int}}

\subsubsection{素因数分解の難しさについて}
「素因数分解は難しい」ということをどこかで聞いたことがあると思う。
2つの素数の積は、素因数分解の一意性より、原理上は2つの素数に分解することが\kenten{できる}。
しかし、それはあくまで「できる」としか言っていない。
ガラスを割ることは容易でも、割れたガラスを元に戻すことが難しいように、それは「不可能」ではないが非常に「困難」なのである\Notes{まだ簡単な方法が見つかっていないだけなのかもしれないが、現時点の人類には難しい問題である。}。
このように、「2つの数を掛ける」ことと「素因数分解をする」ということは、互いに逆の操作であるにも関わらず、一方は簡単で一方は難しい。
暗号理論ではこのような操作(関数)のことを\IND{一方向性関数}{いちほうこうせいかんすう}(one-way function)と呼ぶ。
素因数分解が難しい(と思われている)からこそ\IND{RSA暗号}{RSAあんこう}\Notes{発明者のRonald Linn Rivest, Adi Shamir, Leonard Max Adlemanの3人の頭文字から名付けられた。}などが存在しているのだ。
なお「RSA暗号は素因数分解の難しさを安全性の根拠としている」と紹介されることが多いが、厳密には正しくない。

素因数分解が難しいということを実感するために、今、我々にある「武器」は試し割しかない。
$n$に対して最悪で$\sqrt{n}$回試しに割ってみれば、素因数分解ができる。
これは「難しい」ということができるだろうか？　$n=100$ならば$\sqrt{100}=10$だから大したことはないが、$n$が大きくなるに従って最新のコンピュータでさえ手に負えないほどの回数試し割をしなければならなくなる。

注意しておくが、計算量理論の世界において問題の難しさとは「入力の\kenten{サイズ}」が大きくなるに従って計算時間やメモリ消費量はどのように増加するのか、\textbf{その増大度合い}のことを言う。
素因数分解の場合も、$n$に対して試し割では演算が$\sqrt{n}$回必要だということに興味がある。
そしてよく見落とされるのが、入力の\kenten{サイズ}を基準とすることだ。
これを見落とすと「$\sqrt{n}$回で済むのは速いのでは？」と勘違いしてしまう。
素因数分解問題の入力$n$のサイズは$\log_2{n}$であって、試し割の回数はサイズの増加に伴って指数関数的に増加する。
まったくもって「遅い」アルゴリズムなのである。

\subsubsection{更なる高速化に向けて}
既に2で割り切るか試したのに、4や10で割り切るかを調べる必要はない。
高速化の手法として、割る数を自然数ではなく、素数に限定するということは考えられるが、一方で素数を列挙するコストもあるため、ケースバイケースで対応した方がよいだろう。
そうでないにしても、2以外は奇数のみで試し割をするなどの工夫の余地はある。
試し割とはあまり面白みがないアルゴリズムだと、がっかりするかもしれないが、ともかく素数に関する最初のアルゴリズムを得たわけだ。

