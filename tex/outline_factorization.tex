詳しいアルゴリズムを説明する前に、概要を説明しておこう。
具体的なアルゴリズムの中身を知る必要のない人などは、本節を読むことで素因数分解がいかに困難な問題であるか明らかになるだろう。

「素因数分解は難しい」ということをどこかで聞いたことがあると思う。
2つの素数の積は、素因数分解の一意性より、原理上は2つの素数に分解することが\kenten{できる}。
しかし、それはあくまで「できる」としか言っていない。
ガラスを割ることは容易でも、割れたガラスを元に戻すことが難しいように、それは「不可能」ではないが非常に「困難」なのである\Notes{まだ簡単な方法が見つかっていないだけなのかもしれないが、現時点の人類には難しい問題である。}。
このように、「2つの数を掛ける」ことと「素因数分解をする」ということは、互いに逆の操作であるにも関わらず、一方は簡単で一方は難しい。
暗号理論ではこのような操作(関数)のことを\IND{一方向性関数}{いちほうこうせいかんすう}(one-way function)と呼ぶ。
素因数分解が難しい(と思われている)からこそ\IND{RSA暗号}{RSAあんこう}\Notes{発明者のRonald Linn Rivest, Adi Shamir, Leonard Max Adlemanの3人の頭文字から名付けられた。}などが存在しているのだ。

一般に素因数分解問題とは、与えられた自然数$n$を$n=p_1^{e_1}\cdots p_r^{e_r}$と分解することである。
一方、数論の応用として、現代社会になくてはならない暗号理論の分野においては、もっと限定的な形を考えるのが普通である。
例えば、$n=pq$や$n=p^rq$といった形の自然数に限って考える。
それは言うまでもなく、そのような形の自然数が素因数分解が簡単にできると、ある種の暗号方式が安全ではなくなってしまうからである。

素因数分解アルゴリズムを分類するにあたって1つの切り口となるのが、実行時間が合成数サイズに依存するのか、素因数サイズに依存するか、という点であろう。
既に見た試し割は、素因数サイズに依存している。
つまり、素因数が小さい程早く見つけることができる。
例えば$n=2^k$は、$n$は大きいのだが、試し割で簡単に素因数分解可能である。

それ以外にも、アルゴリズムが決定的か確率的かや、実行時間によっても分類できるだろう。
実行時間について注意しておくが、計算量理論の世界において問題の難しさとは「入力の\kenten{サイズ}」が大きくなるに従って計算時間やメモリ消費量はどのように増加するのか、\textbf{その増大度合い}のことを言う。
素因数分解の場合も、$n$に対して試し割では演算が$\sqrt{n}$回必要だということに興味がある。
そしてよく見落とされるのが、入力の\kenten{サイズ}を基準とすることだ。
これを見落とすと「$\sqrt{n}$回で済むのは速いのでは？」と勘違いしてしまう。
素因数分解問題の入力$n$のサイズは$\log_2{n}$であって、試し割の回数はサイズの増加に伴って指数関数的に増加する。
まったくもって「遅い」アルゴリズムなのである。

\begin{table}[htb]
\centering
\caption{本稿で紹介する素因数分解アルゴリズム一覧}
\label{tb:integer_factorization_list}
\begin{tabular}{|l|l|l|l|l|}
\hline
アルゴリズム                         & 合成数依存/素因数依存 & 決定的/確率的 & 計算量                & 紹介している節 \\ \hline\hline
試し割                               & 素因数依存            & 決定的        &                       & \ref{sssec:trial_division_simple} \\ \hline
Fermat法                             & 素因数依存            & 決定的        &                       & \ref{sssec:fermat_method}         \\ \hline
Lehman法\cite{Lehman1974FactoringLI} & 合成数依存            & 決定的        & $O(n^{1/3})$          & \ref{sssec:lehman_method}         \\ \hline
\end{tabular}
\end{table}
