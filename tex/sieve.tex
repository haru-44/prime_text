素数を列挙するためのアルゴリズムとして、\IND{Eratosthenesの篩}{Eratosthenesのふるい}(sieve of Eratosthenes)は有名だ。
長さ$n$のリストを用意して、
\begin{itemize}
 \item 2の倍数は素数を素数でないとして消し込む
 \item 3の倍数は素数を素数でないとして消し込む
 \item 5の倍数は素数を素数でないとして消し込む……
\end{itemize}
とすることで、素数のみが残る。

\Algo{Eratosthenesの篩}{sieve_of_eratosthenes}{c.f., \rAlgo{sqrt_int}}

1つに対する素数判定を行うには大仰だが、複数回の素数判定を行う場合には効果を発揮する。

篩のアイディアは、素数判定以外にも利用できる。
例えば、与えられた数の素因数分解も可能だ。
リストに記録するのは、「最後に割られた数」である。

\Algo{素因数を篩う}{factor_sieve}{c.f., \rAlgo{sqrt_int}}

もう少し工夫すると、B-smooshな数を篩うことも可能だ。
リストには、書き込むのは、$p^a$の倍数のとき$p$を掛ける。
$B$-smoothな数ならば、インデックスと値が同じになっているはずだ。

\Algo{smoothな数を篩う}{b_smooth_sieve}{}

smoothな数を篩うことは結構重要で、後で紹介する2次篩法などがどうして「篩」という名を冠しているかというと、$B$-smoothな数を篩うからだ。
そして、実際上にしろ理論上にしろ最も時間がかかるのが篩うステップである。
よって、篩の高速化はそのまま素因数分解アルゴリズムの高速化にもつながる。
対数表は画期的な発明だったとされるが、現代の感覚からすると中々理解しづらい。
コンピュータが計算することが当たり前になって、手計算で近似値を求める必要性が乏しいからだ。
対数表の本質的な考えは、$x$と$a^x$とを対応させることにある。
「掛け算が足し算になる」というのは、単純な計算コストという面でも有利だ。
つまり、\rAlgo{b_smooth_sieve}で配列に保持するのは$\log$を取った値にすれば、毎回掛け算をする必要がなく、足し算で済む。
こうすると、実数で扱うため、計算機上では誤差が避けられないが、「$B$-smoothかどうかを(ほぼ正しく)判別したい」という目的において大きな問題ではない。

素数を列挙するためのアルゴリズムとして、Eratosthenesの篩が紹介されることは多いが、それ以外のアルゴリズムが紹介されることは少ない。
Eratosthenesの篩でも十分実用的であり、マニアックな改良まで紹介する必要がないからであろう。

\IND{Sundaramの篩}{Sundaramのふるい}(sieve of Sundaram)の基本的なアイディアは、奇数の積を篩う。
最初から偶数は無視することにすれば、リストのサイズは半分に減って、インデックスは$2x+1$の読み替えを必要とする。
任意の奇数の合成数は、$(2i+1)(2j+1)=2(i+j+2ij)+1$の形で表されることに注意しよう。
$i,j$が$(2i+1)(2j+1)\le n$を満たす範囲を動けば、$n$以下のすべての合成数をチェックすることができる。
一般性を失うことなく$i\le j$を仮定して良いし、$(2i+1)$は$\sqrt{n}$まで動けば十分であることはすぐ分かる。
実装は、オリジンの問題と変数の使い方の問題によって複雑に見えるが、実態は上記を忠実にコードに落とし込んでいるだけである。

\Algo{Sundaramの篩}{sieve_of_sundaram}{c.f., \rAlgo{sqrt_int}}

