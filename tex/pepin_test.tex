Lucasテストを実行するには、$n-1$の素因数が判明している必要があるが、一般的には、$n-1$の素因数を求めることは困難である。
しかし、特殊な形に限定すれば容易である。
$2^{2^k} + 1$という形で表されるFermat数もその一例で、$n-1$の素因数は明らかに2のみである。
Pepinテストは、Fermat数に特化したLucasテストと言える。
ただし、必要性をも示している点において、単なるLucasテストとは一線を画す。
つまり、Pepinテストによって、Fermat数が素数か合成数かを確実に判別できるのである。

\begin{Defi}{\IND{Fermat数}{Fermatすう}, Fermat number}{Fermat_number}
Fermat数$F_k$は、$F_k=2^{2^k} + 1$と表される数である。
\end{Defi}

つまり、$F_0=3, F_1 = 5, F_2 = 17,\ldots$である。
Fermatは、すべてのFermat数が素数であることを予想し、実際、$k \le 4$の場合、$F_k$は素数である。
一方、Eulerは、$F_5$が合成数であることを示し、Fermatの予想が誤りであることを示した。
現在までに素数か合成数かが判明しているFermat数は、$k$が$5$以上においてすべて合成数である。

ところで、日本語における語呂合わせと似た概念で、英語では単語の文字数を使って数字を覚えるということができる。
例えば、``Can I find a trick recalling pi easily (円周率を簡単に思い出すトリックはありますか)" は円周率3.1415926を覚えられる。
一般に、語呂合わせのための文というのはその制約上、どうしても意味不明なものになりがちだが、この例では円周率に関連しており、芸術点が高い。
芸術的で感動すら覚えるのが$F_4=65537$の覚え方で、既に述べたように現在知られている最大のFermat素数であることを思い出そう。
\begin{quotation}
``Fermat prime, maybe the largest (Fermat素数、おそらく最大の||)" \Notes{\cite{A_Computational_Perspective}によれば、 R. Brent に帰せられる。}
\end{quotation}
今後、この芸術性を打ち破る発見があるのかは、神のみぞ知る。

\IND{Pepinテスト}{Pepinてすと}(Pepin's test)は、Fermat数に対する素数判定アルゴリズムである。
Fermat数にLucasの定理を適用してみると、$F_k - 1$の素因数は明らかに2のみであるから、上手くいきそうな気配がある。
単純に適用すれば、
\begin{align*}
\begin{cases}
a^{F_k-1} \equiv 1 \pmod{F_k}\\
a^{(F_k-1)/2} \not\equiv 1 \pmod{F_k}
\end{cases}
\end{align*}
となるような$a$を見つける必要がある。
また、このような$a$が見つけられないとき、本当に合成数なのか、単に探し足りないだけなのかは、Lucasの定理からははっきりとしない。
しかし、Pepinは次のような素数判定法を与えた。
つまり、1つの式で素数かどうかを明らかにすることができる。

\begin{Theo}{}{pepin}
$k\ge1$に対し、Fermat数$F_k$が素数であるとき、かつそのときのみ、$3^{(F_k - 1)/2}\equiv-1\pmod{F_k}$
\end{Theo}

\ruby{斯}{か}くなる数式が成り立つとき$F_k$が素数であるという主張は、Lucasの定理(\rTheo{Lucas_theorem})から得られるが、重要な点は逆が成り立つことである。
なお、謎の基数3が登場するが、他の適当な値に変更可能である。
その代替可能な値は、$5,6,7,10,\ldots$と続くことが知られている\Notes{\url{https://oeis.org/A129802}}。

最後にPepinテストを実装してみよう。
と言っても、至極簡単な実装にしかならない。

\Algo{Pepinテスト}{pepin_test}{}

2022年の時点で$F_{33}$は素数か合成数か判明していない\Notes{\url{http://www.prothsearch.com/fermat.html}}。
33という数字に惑わされて、$F_{33}$それ自体が小さいと誤解しがちだが、2進数表記で約86億桁、この数を保存するだけで約1Gbyte必要な数である。
いくら簡潔なアルゴリズムだろうと、扱う数が大きくなれば計算が困難になるのは当然だ。
