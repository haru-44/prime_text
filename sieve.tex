素数を列挙するためのアルゴリズムとして、\IND{Eratosthenesの篩}{Eratosthenesのふるい}(sieve of Eratosthenes)は有名だ。
長さ$n$のリストを用意して、
\begin{itemize}
 \item 2の倍数は素数を素数でないとして消し込む
 \item 3の倍数は素数を素数でないとして消し込む
 \item 5の倍数は素数を素数でないとして消し込む……
\end{itemize}
とすることで、素数のみが残る。

\Algo{Eratosthenesの篩}{sieve_of_eratosthenes}{c.f., \rAlgo{sqrt_int}}

1つに対する素数判定を行うには大仰だが、複数回の素数判定を行う場合には効果を発揮する。

篩のアイディアは、素数判定以外にも利用できる。
例えば、与えられた数の素因数分解も可能だ。
リストに記録するのは、「最後に割られた数」である。

\Algo{素因数を篩う}{factor_sieve}{c.f., \rAlgo{sqrt_int}}

もう少し工夫すると、B-smooshな数を篩うことも可能だ。
リストには、書き込むのは、$p^a$の倍数のとき$p$を掛ける。
B-smoothな数ならば、インデックスと値が同じになっているはずだ。

\Algo{smoothな数を篩う}{b_smooth_sieve}{}

smoothな数を篩うことは結構重要で、後で紹介する2次篩法などがどうして「篩」という名を冠しているかというと、B-smoothな数を篩うからだ。
そして、実際上にしろ理論上にしろ最も時間がかかるのが篩うステップである。
よって、篩の高速化はそのまま素因数分解アルゴリズムの高速化にもつながる。
対数表は画期的な発明だったとされるが、現代の感覚からすると中々理解しづらい。
コンピュータが計算することが当たり前になって、手計算で近似値を求める必要性が乏しいからだ。
対数表の本質的な考えは、$x$と$a^x$とを対応させることにある。
「掛け算が足し算になる」というのは、単純な計算コストという面でも有利だ。
つまり、\rAlgo{b_smooth_sieve}で配列に保持するのは$\log$を取った値にすれば、毎回掛け算をする必要がなく、足し算で済む。
こうすると、実数で扱うため、計算機上では誤差が避けられないが、「$B$-smoothかどうかを(ほぼ正しく)判別したい」という目的において大きな問題ではない。

