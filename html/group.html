<html lang="ja">
  <head>
    <title>group</title>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=py&skin=sunburst"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>group</h1>
<p>Fermatの小定理は、群という枠組みで考えると、新たな発見を与えてくれる。
そのために、群を導入しよう。
</p>
<p>深い議論、より本質を見つけるためには、抽象化ということをしなければならない。
あるいは記号の羅列にしか見えないそれは、数学が嫌いな人からすればアレルギー反応を起こすこと必定だ。
そういう人たちは、数学とは自然界を写し取った世界であり、人工物が混入することを忌避する信念を持っているように思える。
しかし、「数」それ自体が人工物であるわけで、矛盾をはらんでいる。
</p>
<p>\begin{quote}
``数"は、人間の認知能力を補完し、延長するために生み出された道具である(中略)。
「自然数(natural number)」という言葉があるが、それは決してあらかじめどこかに「自然に」存在しているわけではない。
「自然」と呼ばれるのは、もはや道具であることを意識させないほどに、それが高度に身体化されているからである。 | 森田真生『数学する身体』
\end{quote}
</p>
<p>科学は「同じようなもの」を見いだし、それを「同じ」と認識することによって発展してきたとも言える。
例えば、ペン1本とノート1冊には何の関係性もないが、それを、同じ「1」と認識できるのである。
同じように、足し算とか掛け算とかの「骨」である部分を抜き出すのだ。
そして、この「骨」を「群」と名付けたのである。
当初は、「なぜ5次以上の方程式の解を求める公式が存在しないのか」という疑問に応えるために創り出された道具だった。
時代が下るにつれて、暗号理論や誤り訂正符号などの情報技術の根幹を成す理論に利用され、果てはこの世界の根源を探る素粒子物理学にも利用されている。
こんなことを言うと、「群」は恐ろしく複雑で難解なのではないか、と思うかも知れない。
そんな予想に反して、(少なくとも)複雑とは言い難い。
むしろ、貧相な見た目であるとも言える。
それにも関わらず、誕生から200年以上にも渡って科学者を飽きさせないエンターテイナーであるのだ。
</p>
<p>そんな「群」について学ぼう。
最初のイメージとして、足し算や掛け算を抽象化したものを「群」と呼ぶ。
定義もなしに言ってしまうけれど、整数上での足し算は群を成す。
あるいは、有理数上での掛け算は群を成す。
このように、舞台となる整数であったり有理数であったりといった集合と、そこでの振る舞いが一定の条件を満たしていれば群と呼べる。
逆に言えば、この条件を満たしていれば、足し算や掛け算に似ていなくとも、群と呼べるのである{ここでは取り上げないが、阿弥陀くじやルービックキューブなどは、群の理論で説明できる。}。
一方で条件を満たしていない、自然数上での足し算や整数上での掛け算は、群とは呼べないのである。
この辺りは、定義を述べてから詳しく見ていこう。
足し算も掛け算も一緒くたに扱うのが群なのであるが、足し算と掛け算の類似性を見るには、\(0\)と\(1\)に着目しよう。
足し算における\(0\)と、掛け算における\(1\)は、どんな数に\(0\)を足しても(あるいは\(1\)を掛けても)変化しないという意味で似通っている。
これを<strong>単位元</strong>(identity element)と呼び、単位元が存在することが群であるための条件の1つとなっている。
</p>
<p>ともかく、群を真面目に定義してみよう。
つまり、<strong>分かり切っていることを大仰に書き下す</strong>のである。
まずは、二項演算を定義する。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
集合\(G\)上で定義される写像
\begin{align*}
\mu : G \times G \to G
\end{align*}
を\(G\)上の二項演算と呼び、特に\(\mu(x,y)=z\)を\(x\circ_{\mu}y=z\)と書き、二項演算を\(\circ_{\mu}\)とする記法が一般的である。
</div>

<p>小学校以来習ってきた足し算や掛け算は、2変数関数と同一視できるのである{というか、書き方の違いだけで本質的には何ら違わない}。
また、演算が<strong>閉じている</strong>とは\(G\times{G}\)の行き先が必ず\(G\)であることであり、\(g_1\circ{g_2}\not\in{G}\)となるような\(g_1,g_2\in{G}\)が存在するときには演算が閉じているとは言わない。
例えば、自然数同士の足し算は、常に自然数となるので閉じていると言えるが、自然数同士の引き算は、例えば\(3-5\)は自然数にはならないので、閉じていない。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
群\(G\)において、\(G\)の要素を元と呼ぶ。
</div>

<p>群は、集合と二項演算の組によって決まる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
集合\(G\)と二項演算\(+\)の組\((G,+)\)について次の4つの条件が成り立つとき\((G,+)\)を<strong>群</strong>と呼ぶ。
<ol>
 <li> 二項演算\(+\)について集合\(G\)は閉じている。
 <li> (<strong>結合法則</strong>)任意の\(a,b,c{\in}G\)について\((a{+}b){+}c=a{+}(b{+}c)\)が成り立つ。
 <li> (<strong>単位元</strong>の存在)任意の\(a{\in}G\)について\(a{+}e_+=e_+{+}a=a\)となる単位元\(e_+\in{G}\)が存在する。
 <li> (<strong>逆元</strong>の存在)任意の\(a{\in}G\)について\(a{+}(-a)=(-a){+}a=e_+\)となる逆元\(-a\in{G}\)が存在する。
</ol>
</div>

<p>特に、群\((G,+)\)が任意の\(a,b{\in}G\)で
\begin{eqnarray*}
a + b = b + a
\end{eqnarray*}
ならば、\((G,+)\)を<strong>可換群</strong>(commutative group)あるいは<strong>アーベル群</strong>(abelian group)と呼ぶ。
また、慣例的に加法について群ならば加法群と呼び、逆元を\(-a\)、単位元を0と表し、乗法について群ならば乗法群と呼び、逆元を\(a^{-1}\)、単位元を1と表すが、本質的に違いはない。
同様に、スカラー倍についても表記上の差異が見られる。
加法群\((G,+)\)ならば\(a\in{G}\)と非負整数\(k\)について
\begin{eqnarray*}
ka=
\begin{cases}
a + (k-1)a, & \mbox{if } k > 0\\
0, & \mbox{otherwise}
\end{cases}
\end{eqnarray*}
であるが、乗法群\((G,\times)\)ならば
\begin{eqnarray*}
a^{k}=
\begin{cases}
a \times a^{k-1}, & \mbox{if } k > 0\\
1, & \mbox{otherwise}
\end{cases}
\end{eqnarray*}
と表されるのが通例である。
</p>
<p>集合\(G\)に加えて二項演算\(+\)も明らかにならなければ群と呼べないのだが、大抵「群\(G\)」と書かれ、二項演算の記載は省略される。
ここでも、以降はそのように表す。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
群\(G\)の位数とは、\(G\)の元の要素数であり、\(|G|\)あるいは\(\sharp G\)と書く。
</div>

<p>位数には、群の位数と、後で紹介する元の位数があり、まったく別物であるから、注意が必要である。
</p>
<p>いくつかの具体例を見てみよう。
\begin{align*}
\mathbb{Z}_n = \{0,1, \ldots, n-1\}
\end{align*}
という集合は加法について群である。
ただし、通常の意味での加法ではもちろん演算について閉じていないから、ここでの加法の後に\(n\)で剰余算をする。
</p>
<p>復習すると剰余算について、\(a\)を\(n\)で割った余りを\(b\)とすることを、\(a \% n =b\)と書くことにすると、
\begin{align*}
(a \% n) + (b \% n) &= (a + b) \% n\\
(a \% n) - (b \% n) &= (a - b) \% n\\
(a \% n) \times (b \% n) &= (a \times b) \% n\\
\end{align*}
が成り立ったのであった。
つまり、剰余の順番は気にせずに良い。よって、\((\mathbb{Z}_n,+)\)は(剰余算をする)加法において群を成す。
</p>
<p>では、同じように乗法についても群となるのではないかという予想ができるが、そうではない。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(a,n\in\mathbb{Z}\)が互いに素であるとき、かつそのときのみ\(ax=1\pmod{n}\)となるような\(x\)が存在する。
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)
\(\gcd(a,n)=1\)ならば、\(ax+ny=1\)を満たす整数\(x,y\)が存在する()。
\(\bmod{n}\)においては、\(ax+ny\equiv1\pmod{n}\)より、\(ax\equiv1\pmod{n}\)。
</div>

<p>つまり、\(a\)と\(n\)が互いに素でないと、逆元が存在しないのである。
例えば、\(a=4,n=12\)のとき、\(ax \% n =1\)となるような\(x\)が存在しないため\(\mathbb{Z}_{12}\)は群にならない。
ちなみに、逆元を持つ元を<strong>可逆元</strong>(invertible element)あるいは<strong>単元</strong>(unit)と呼ぶ。
換言すれば、群はすべての要素が可逆元である。
</p>
<p>逆元を求めるには、証明で見たように拡張Euclidの互除法を使えばよい。
具体的には次のようになる。
</p>
<pre class="prettyprint">from typing import Optional

from extended_gcd import extended_gcd


def inverse_mod(a: int, n: int) -> Optional[int]:
    """ 法nにおけるaの逆元xを返す。つまり、xはa * x = 1 (mod n)を満たす。

    Args:
        a (int): 逆元をもとめる数
        n (int): 法

    Returns:
        x (int or None): a * x = 1  (mod n)を満たす整数 1 <= x < n
                         そのようなxが存在しないとき、None

    Examples:
        >>> inverse_mod(3, 5)
        2
        >>> inverse_mod(2, 4)
    """
    a %= n
    g, x, _ = extended_gcd(a, n)
    if g == 1:
        return x % n
</pre>

<p>この事実を逆に考えればこのような、単元ではない元を除けば群になるとも言える。
そこで、次のような集合を定義する。
</p>
<p>\begin{align*}
\mathbb{Z}_n^* = \{a : a \in \mathbb{Z}_n, \gcd(a,n) = 1\}
\end{align*}
</p>
<p>\((\mathbb{Z}_n^*,\times)\)は乗法において群を成し、この群を<strong>既約剰余類</strong>と呼ぶ。
特に\(n\)が素数\(p\)の場合は、\(0\)以外すべての要素が\(p\)と互いに素である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)
\begin{align*}
\mathbb{Z}^*_5 &= \{1, 2, 3, 4\}\\
\mathbb{Z}^*_{12} &= \{1, 5, 7, 11\}\\
\mathbb{Z}^*_{15} &= \{1,2,4,7,8,11,13,14\}
\end{align*}
</div>

<p>さて、Fermatの小定理を群の言葉で書き直そう。
\(\bmod{n}\)における現象は、\(\mathbb{Z}_n^*\)という群における現象に過ぎないのだ。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
群\(G\)と任意の元\(a\in G\)において、次が成り立つ。
\begin{align*}
a^{|G|} = e
\end{align*}
ここで、\(|G|\)は群の位数、\(e\)は群\(G\)の単位元とする。
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)
可換群の場合について証明する。
\(G\)の元すべてに\(a\in{G}\)をかけた集合\(aG\)を考える。
この\(aG=\{ax:x\in{G}\}\)は\(G\)に一致する。
なぜなら、群の定義より任意の\(a,b,c\in{G}\)について\(ab\neq{ac}\)が言えるので、\(aG\)は\(G\)がシャッフルしただけで、被りがない。
よって、当然\(G\)の総積と\(aG\)の総積は一致する。
\begin{align*}
\prod_{g\in{G}}g = \prod_{g\in{aG}}g
\end{align*}
分かりやすく書くならば、\(G=\{g_1,g_2,\ldots,g_n\}\)ということにして、
\begin{align*}
g_1g_2\cdots g_n = ag_1 ag_2 \cdots ag_n
\end{align*}
と言うことである。
ここで、\(a\)は\(|G|\)個あるから全て集めてきて
\begin{align*}
g_1g_2\cdots g_n = a^{|G|}g_1 g_2 \cdots g_n
\end{align*}
となり、両辺を\(g_1g_2\cdots{g_n}\)で割ると\(a^{|G|}=e\)を得る。
</div>

<p>例えば、\(G\)を\(\mathbb{Z}_n\)とすれば、
\begin{align*}
an \equiv 0 \pmod{n}
\end{align*}
という当たり前の結果に過ぎない。
また、\(G\)を\(\mathbb{Z}^*_p\)(ただし、\(p\)は素数)とすれば、\(|G|=p-1\)であるから、
\begin{align*}
a^{p-1} \equiv 1 \pmod{p}
\end{align*}
となり、Fermatの小定理に一致する。
</p>
<p>では、一般の\(n\)の場合\(\mathbb{Z}^*_n\)はどうなるだろうか？　\(\mathbb{Z}^*_n\)の位数とは、定義より\(n\)と互いに素な整数の個数になる。これを新しく\(\varphi(n)\)と定義しよう。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
正整数\(n\)に対して、\(n\)以下の、\(n\)と互いに素な整数の個数を\(\varphi(n)\)とする。
</div>

<p>そうすると、任意の\(n\)と互いに素な\(a\)について、次が成り立つことが分かる。
\begin{align*}
a^{\varphi(n)} \equiv 1 \pmod{n}
\end{align*}
とは言え、これでは\(|G|\)を\(\varphi(n)\)に置き換えただけで、情報が増えていないのだが、\(\varphi(n)\)は次のように計算できる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(n\)が\(n=p_1^{e_1}p_2^{e_2}\cdots p_r^{e_r}\)と素因数分解できるとき、\(\varphi(n)\)は次のように計算できる。
\begin{align*}
\varphi(n) = n \prod_{k=1}^r \left( 1 - \frac{1}{p_k} \right)
\end{align*}
</div>

<p>\Algo{Eulerの\(\varphi\)関数}{totient_function}
</p>
<p>計算できると言ったが、中身を見れば分かる通り、まず\(n\)を素因数分解する必要がある。
巷ではよく、RSA暗号は素因数分解問題が難しいため安全という解説がなされる。
それは、「素因数分解→\(\varphi(n)\)の計算→RSA暗号解読」という手順によってなされるわけであるが、\(\varphi(n)\)の計算に素因数分解が必須であるかは分かっていない。
つまり、素因数分解をしなくとも\(\varphi(n)\)を計算できる可能性があって、素因数分解問題が難しいままでも、RSA暗号を解読することが可能かもしれない。
</p>
<p>次に、中国の剰余定理を紹介しよう。
これは、『孫子算経』に、「3で割ると2余り、5で割ると3余り、7で割ると2余る数は何か」という問題とその解法が載せられたことに端を発する。
この解法は、本来ならきちんと学ばなければならない所だが、さらっと載せる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(m_1,m_2,\ldots,m_k\)はどの2つも互いに素とする。
連立合同式
\begin{align*}
x &\equiv a_1 \pmod{m_1}\\
x &\equiv a_1 \pmod{m_2}\\
&\vdots\\
x &\equiv a_k \pmod{m_k}
\end{align*}
を満たす\(x\)が\(m_1m_2\cdots m_k\)を法としてただ1つ存在する。
</div>

<pre class="prettyprint">from typing import List, Optional, Tuple

from extended_gcd import extended_gcd


def chainese_remainder_theorem(congruent_exps: List[Tuple[int, int]]) \
                                    -> Optional[Tuple[int, int]]:
    """ 中国の剰余定理を用いて、連立合同式を解く。

    Args:
        congruent_exps ([(int, int)]): 合同式のリスト

    Returns:
        r, M ((int, int) or None): congruent_expsを満たすような r (mod M)
                                     存在しなければ None

    Examples:
        >>> # r = 2 (mod 3)
        >>> # r = 4 (mod 5)
        >>> # を満たすような r (mod M) を求める。
        >>> chainese_remainder_theorem([(2, 3), (4, 5)])
        (14, 15)
    """
    r, M = 0, 1
    for var, mod in congruent_exps:
        g, x, _ = extended_gcd(M, mod)
        if (var - r) % g != 0:
            return None
        rem = mod // g
        r += M * (var - r) // g * (x % rem)
        M *= rem
    return r % M, M
</pre>

<p>今注目したいのは、中国の剰余定理の系である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>系</strong>)
互いに素な整数\(m,n\)とすると、次が成り立つ。
\begin{align*}
\mathbb{Z}_{mn} &\cong \mathbb{Z}_m \times \mathbb{Z}_n\\
\mathbb{Z}_{mn}^* &\cong \mathbb{Z}_m^* \times \mathbb{Z}_n^*
\end{align*}
</div>

<p>一般には\(m,n\)の2つの場合だけでなく、\(k\)個の場合でも成り立つ。
</p>
<p>色々と未登場の記号を使ったが、簡単な例で説明する。
例えば、\(\mathbb{Z}_3\times\mathbb{Z}_4\)とは2つの群の元をペアにしたものである。
つまり、
\begin{align*}
\mathbb{Z}_3\times\mathbb{Z}_4 = \{(a,b) : a \in \mathbb{Z}_3, b \in \mathbb{Z}_4\}
\end{align*}
として、演算はそれぞれ別個に\((a_1+a_2,b_1+b_2)\)などとすれば、\(\mathbb{Z}_3\times\mathbb{Z}_4\)もまた群となる。
では、これがどういう群かというと、が示すには、\(\mathbb{Z}_{12}\)と本質的には同じになる。
「本質的には」とは、両者に一対一対応があることを意味し、例の場合なら任意の\(A\in\mathbb{Z}_{12}\)は\((A \% 3, A \% 4)\)という変換によって\(\mathbb{Z}_3\times\mathbb{Z}_4\)の元になる。
逆に\(\mathbb{Z}_3\times\mathbb{Z}_4\)の元は、中国の剰余定理によって\(\mathbb{Z}_{12}\)の元と対応付けられる。
このような一対一対応を同型写像と呼び、次のように定義する。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
2つの群を\((G, \dagger),(H, \star)\)とする。
\(f:G\to H\)が任意の\(a,b\in G\)について次を満たすとき、\(f\)を準同型写像と呼ぶ。
\begin{align*}
f(a) \star f(b) = f(a \dagger b)
\end{align*}
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
2つの群を\(G,H\)とする。
準同型写像\(f:G\to H\)が全単射のとき、\(f\)を同型写像と呼ぶ。
</div>

<p>2つの群\(G,H\)に同型写像が存在するとき、この2つの群は同型であると呼び、\(G\cong H\)と書く{教科書によっては\(G\simeq H\)と書く流儀もある。}。
また、単に準同型写像、同型写像、あるいは同型と呼んだが、群における同型なので、区別する必要があるときは<strong>群</strong>準同型写像、<strong>群</strong>同型写像、<strong>群</strong>同型と呼ぶことがある。
特に、後に説明する環や体にも同型写像が存在するが、2つが「同じ」であるということを定義したいというココロは、群の場合と変わりない。
</p>
<p>\(\mathbb{Z}_m \times \mathbb{Z}_n\)の``\(\times\)"は、直積と呼ばれる、新たな群を生み出す操作である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
2つの群を\((G, \dagger),(H, \star)\)とする。
直積群\(G \times H\)を次のように定義する。
<ul>
 <li> 元は\((g, h)\)とする。ここで、\(g \in G, h \in H\)。
 <li> 2項演算は、任意の元\((g_1, h_1), (g_2, h_2)\in G \times H\)について\((g_1, h_1)\cdot(g_2, h_2) = (g_1 \dagger g_2, h_1 \star h_2)\)
</ul>
</div>

<p>似た概念に、\(G \oplus H\)と書く<strong>直和</strong>(direct sum)がある。
直積と同じく群から新たな群をつくり出す操作であるが、有限個の群に対してであれば両者は一致する。
無論、ここでは無限直和や無限直積を扱わないので、\(G \times H\)と書いても、\(G \oplus H\)と書いても言っていることは同じである{他にも、<strong>半直積</strong>(semidirect product)などもあるが、名前を紹介に留める。}。
</p>
<p>\(\mathbb{Z}_n\)について、いくつか注意しておこう。
\(\mathbb{Z}_n\)は\(\mathbb{Z}/n\mathbb{Z}\)と書かれることもあるが、意味に違いはない。
\(\mathbb{Z}/n\mathbb{Z}\)は、\(n\)の倍数が成す群を\(n\mathbb{Z}\)と定義し、<strong>商群</strong>(quotient group, factor group)あるいは<strong>剰余群</strong>と呼ばれる新たな群を作る操作``\(/\)"を使って作った群という意味である。
また、巡回群\(C_n\)も\(\mathbb{Z}_n\)と同型である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
群\(G\)のある元\(g\in G\)が
\begin{align*}
G = \{g^n : n \in \mathbb{Z}\}
\end{align*}
であるとき、この群を位数\(n\)の巡回群\(C_n\)と呼ぶ。
また、この\(g\)を<strong>生成元</strong>(generator)あるいは<strong>原始元</strong>(primitive)と呼ぶ。
</div>

<p>\(\mathbb{Z}_n\)は1が生成元となるので\(C_n\)と同型になることはすぐ分かる。
しかも、Lagrangeの定理の系より、素数位数の群は同型を除いて巡回群しかない。
つまり、ある群の位数が素数なら、その群は巡回群であることが確定する。
</p>


</body></html>