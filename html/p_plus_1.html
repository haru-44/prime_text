<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=py&skin=sunburst"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>p_plus_1</h1>
<p>やは、素数に関する定理だが、素数判定にしか使えないわけではない。
\(n\)を合成数、\(p\)を\(n\)の素因数としよう。
\(U_{p-\epsilon} \equiv 0 \pmod{p}\)が成り立つということは、\(\gcd(U_{p-\epsilon} \bmod{n}, n)\)は\(n\)の非自明な因数であると期待できる、というのは、\(p-1\)法と同じ理屈である。
ここで、\(\epsilon\)と仮に置いたが、これは\(+1\)か\(-1\)のどちらかであり、\(p\)やLucas数列のパラメータ\(a,b\)によって変わるのであった。
\(+1\)のときは\(p-1\)法が因数分解できる数が素因数分解できるだけで面白みがない。
<strong>Williamsの\(p+1\)法</strong>(以下、\(p+1\)法)は、\(n\)の素因数\(p\)について\(p+1\)が\(B\)-smoothであるという仮定を置いた素因数分解アルゴリズムである。
無論、\(p\)がそもそも不明であることからも分かる通り、意図して\(\epsilon=1\)となるようにすることはできない。
Lucas数列のパラメータ\(a\)をランダムに選んで、見込みがなければ別の\(a\)で試す、ということも必要となる。
</p>
<p>\(p+1\)法では、扱いやすいため主にLucas数列\(\{V_n\}\)を使う。
これまで主にLucas数列と言えば\(\{U_n\}\)しか扱ってこなかったが、\(\{V_n\}\)でも\(\{U_n\}\)とほぼ同じことが言える。
ただし、\(V_0=2\)のため周回して戻ってくる先も0ではなく2である。
</p>
<p>これまで紹介したFibonacci数列とLucas数列を求めるアルゴリズム(, )は、愚直に計算するだけで効率が悪い。
悪いだけでなく、ちょっと大きい数を与えると落ちてしまう。
しかも、\(p-1\)法の類似物を考えるということは、\(V_j\)から\(V_{jk}\)を計算できて欲しい。
そこで、だ。
</p>
<p>\Algo{Lucas数列\(\{V_n\}\)}{lucas_sequence_v}
</p>
<p>このアルゴリズムは、\(\{V_n\}\)の
\begin{align*}
V_{j+k} = V_jV_k - b^jV_{k-1}
\end{align*}
という性質の特別の場合(\(b=1\)で、\(k=j\)及び\(j=Nj,k=N(j+1)\))を用いる。
そうすると、
\begin{align*}
V_{2j} &= V_j^2 - 2\\
V_{N(2j+1)} &= V_{Nj}V_{N(j+1)} - V_N
\end{align*}
を得るので、適切に適用していけば\(V_j\)から、\(V_{jk}\)を効率的に計算できるというわけだ。
</p>
<p>最後に、\(p+1\)法のアルゴリズムを紹介して終わろう。
との類似にも注目して見て欲しい。
</p>
<pre class="prettyprint">import math

from sympy import primerange

from lucas_sequence_v import lucas_sequence_v


def p_plus_1_method(n: int, *, B: int, a: int = 5) -> int:
    """ p+1法によって、nの素因数分解を行う。

    Args:
        n (int): 素因数分解を行う整数
        B (int): nの素因数をpとしたとき、p+1がB-smoothであることを仮定する。
                 一般論として、Bを大きくすれば素因数を見つけやすくなるが、計算時間がかかる。
        a (int): Lucas数列のパラメータ。delta=a**2-4, nの素因数をp としたとき、deltaはpを法として
                 平方非剰余でなければならない。もちろん、素因数が判明していない状況なので、
                 ランダムに選んで平方非剰余であることを祈る(失敗すればaを変更する)。
                 平方剰余の場合、因数分解できる数はp-1法に一致し、p-1法の劣化版になる。

    Returns:
        int: nの非自明な約数。素因数分解に失敗したときは、1

    Examples:
        >>> # 1062637 = 1013 * 1049
        >>> # 1049 + 1 = 2 * 3 * 5**2 * 7
        >>> p_plus_1_method(1062637, B=7, a=13)
        1049
    """
    v = a
    for prime in primerange(1, B + 1):
        l = math.floor(math.log(n) / math.log(prime))
        v = lucas_sequence_v(v, prime**l, n)
    d = math.gcd(v - 2, n)
    if 1 < d < n:
        return d
    return 1
</pre>


</body></html>