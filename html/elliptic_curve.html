
<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>elliptic_curve</h1>まず、「楕円曲線」とは、
\begin{align}
\label{eq:elliptic_curve_1}
y^2 = x^3 + ax + b
\end{align}
と書ける方程式、あるいは同じことであるが、
\begin{align}
\label{eq:elliptic_curve_2}
y^2 = x^3 + Cx^2 + Ax + B
\end{align}
と書ける方程式のことである。
厳密には、「標数が2でも3でもないとき」などの前置きが必要になるが、ここでは一旦忘れる。
\(a,b\)や\(A,B,C\)の値によって曲線の形は様々に変わり得るが、多くの類書が注意するようにこの形が楕円であるわけではない。
古くは、楕円の弧長を求める際に必要となる<strong>楕円積分</strong>(elliptic integral)に端を発し、Niels Abelによって、楕円積分の逆関数として<strong>楕円関数</strong>(elliptic function)が発見されたという歴史がある故である。
楕円積分は、高校で習う程度の積分テクニックでは太刀打ちできない難物で、Legendreは、Legendre記号()などに名を残す偉大な数学者であるが、彼の生涯の大部分を費やしても<strong>楕円積分そのものを考えるよりも、逆転させた方が簡単になる</strong>ということに気付けなかった。
この歴史的挿話は、学ぶことが多いように感じられるが、改めて注意を添えるならば、楕円<strong>積分</strong>と楕円<strong>関数</strong>、楕円<strong>曲線</strong>はいずれも別物である。
2種類の形で紹介したが、両者に差異はないことは、<strong>Tschirnhaus変換</strong>(Tschirnhaus transformation)を知っていれば分かる。
用途によって適宜使い分けるので、一方しか紹介しない教科書もあるが混乱しないようにしたい。

また、どんな体で考えるかも重要で、ここでは基本的に有限体\(\mathbb{F}_q\)を考えるが、複素数体\(\mathbb{C}\)や有理数体\(\mathbb{Q}\)が歴史的には先行するし、まったく別物と思えるほど駆使するテクニックは異なる。
何が言いたいかというと、ここで紹介する「楕円曲線」とは、本当の楕円曲線のほんの一面を垣間見ているに過ぎないということだ。

試しに、<strong>一般的な</strong>楕円曲線を定義してみよう。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
体\(K\)上の楕円曲線\(E\)は、次の形の、任意の点において滑らかであるような方程式で与えられる曲線である。
\begin{align*}
y^2 + a_1xy + a_3y = x^3 + a_2x^2 + a_4x + a_6
\end{align*}
</div>

\(K\)の標数が2でないなら、\(a_1 = a_3 = 0\)としても一般性を失わない{なお、標数2における楕円曲線も興味深い研究対象である。}。
更に標数が3でもないなら、Tschirnhaus変換(\(x\to x-a_2/3\)という変数変換)によって\(x^2\)項も削除できるが、既に述べたように用途によって使い分ける。
「滑らか」という条件は、標数が2でないなら右辺の3次式が重根を持たないことと同値である。
つまり、式(\ref{eq:elliptic_curve_1})においては、\(4a^3+27b\neq0\)であること、式(\ref{eq:elliptic_curve_2})においては、\(4A^3+27B^2-18ABC-A^2C^2 + 4BC^3\neq0\)であることが要請される。

例えば、\(y^2=x^3-x\)を考えてみよう。
\(a=-1,b=0\)の場合だ。
\(4a^3+27b=-4\neq0\)なので確かに条件を満たしている。
興味あるのは、この楕円曲線の解であるが、すぐさま\((x,y)=(0,0),(\pm1,0)\)という解が思いつく。
他には存在するだろうか？

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(y^2=x^3-x\)の有理数解は、
\begin{align*}
(x,y) = (0,0), (\pm1, 0)
\end{align*}
のみである。
</div>

Fermat自身は、<strong>Fermatの最終定理</strong>(Fermat's Last Theorem)を証明したと主張したが、今では多くの人が懐疑的である。
それでもFermatが確実に証明したとされているのが\(n=4\)の場合、つまり、を証明したことは確かである。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(x^4+y^4=z^4\)の自然数解は存在しない。
</div>

Fermatは、を証明し、そこからを導いたが、実はを楕円曲線の言葉に言い換えたのがであって、両者は同じことを言っているのである。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
3辺の長さが整数で面積が平方数である直角三角形は、存在しない。
</div>

このような楕円曲線がなぜ重要なのだろうか。
その重要性を語るには何万語かけても足りないが、ここで注目するのは群を成すという点である。
正確には、楕円曲線上の点に、無限遠点と呼ばれる点\(O\)を加えた点の集合は群を成す。
この群を、体\(K\)と楕円曲線\(E\)を使って\(E(K)\)と書こう。
つまり、楕円曲線上の任意の点\(P,Q\)には加法(足し算)が定義できるのだ。
この演算を要約すれば、「直線が、楕円曲線と交わる3点の和はゼロになる」ということになる。
ここでは深く考えずに、次のような計算によって「足し算っぽい」ことができるとボンヤリ分かれば十分だ。

\(P=(x_P,y_P)\),\(Q=(x_Q,y_Q)\)とする。\(P+Q\)の座標\((x_{P+Q},y_{P+Q})\)は、
\(P\neq Q\)のとき、
\begin{align*}
x_{P+Q} &= \alpha^2 - x_P - x_Q\\
y_{P+Q} &= -y_P + \alpha(x_P - x_{P+Q})
\end{align*}
ただし、
\begin{align*}
\alpha = \frac{y_Q - y_P}{x_Q - x_P}
\end{align*}
\(P=Q\)のとき、
\begin{align*}
x_{P+Q} &= \beta^2 - 2x_P\\
y_{P+Q} &= -y_P + \beta(x_P - x_{P+Q})
\end{align*}
ただし、
\begin{align*}
\beta = \frac{3y_P^2 + a}{2y_P}
\end{align*}

また、複数回の加法を次のように書くこととする。
\begin{align*}
[m]P = \underbrace{P+P+\cdots+P }_{m\text{ times}}
\end{align*}
単に\(mP\)と書かれることもあるが、整数と楕円曲線上の点とを区別するために、ここではあえてこのように書く。

再度、\(E:y^2=x^3-x\)にご登場いただこう。
によれば、有理数点は3つだから、
\begin{align*}
E(\mathbb{Q}) = \{O, (0,0), (\pm1,0)\}
\end{align*}
という群を成す。
しかも、すべての元で\([2]P=O\)を満たすから
\begin{align*}
E(\mathbb{Q}) \cong \mathbb{Z}_2 \times \mathbb{Z}_2
\end{align*}
という群である。

有理数体\(\mathbb{Q}\)上の楕円曲線\(E(\mathbb{Q})\)がどのような群になるかということに関して、<strong>Mordellの定理</strong>(Mordell's theorem)が有名であるが、有限体\(\mathbb{F}_q\)上の楕円曲線\(E(\mathbb{F}_q)\)においても類似の結果が知られている。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
有限体\(\mathbb{F}_q\)上の楕円曲線\(E(\mathbb{F}_q)\)は、次のいずれかと同型である。
<ul>
 <li> 巡回群
 <li> 2つの巡回群の直積\(\mathbb{Z}_{d_1}\times\mathbb{Z}_{d_2}\)
</ul>
ここで、\(d_1 \mid d_2\) かつ \(d_1 \mid q - 1\) である。
</div>

から例えば、群\(E(\mathbb{F}_7)\)は巡回群になる以外に、
<ul>
 <li> \(\mathbb{Z}_2 \times \mathbb{Z}_2, \mathbb{Z}_2 \times \mathbb{Z}_4, \mathbb{Z}_2 \times \mathbb{Z}_6,\ldots\)
 <li> \(\mathbb{Z}_3 \times \mathbb{Z}_3, \mathbb{Z}_3 \times \mathbb{Z}_6, \mathbb{Z}_3 \times \mathbb{Z}_9,\ldots\)
</ul>
となる可能性があることが分かる(実際はによって更に限定される)。

\(E(\mathbb{F}_p)\)の具体的な元を枚挙することは、一般には困難だが、位数が小さければ比較的簡単だ。
まず、無限遠点\(O\)は必ず存在する。
\(x\in F\)を\(x^3+ax+b\)に代入してみて、平方非剰余なら対応する\(y\)は存在しないし、平方剰余なら\((x,\pm\sqrt{x^3+ax+b})\)の2点が元である。
\(x^3+ax+b \equiv 0 \pmod{n}\)なら、\((x,0)\)の1点が元である。
よって、群の位数は次のように<strong>正確</strong>に求められる。
なお、カッコはLegendre記号()である。
\begin{align*}
\sharp E(\mathbb{F}_p) = p + 1 + \sum_{x \in \mathbb{F}_p} \left( \frac{x^3+ax+b}{p} \right)
\end{align*}

<pre class="prettyprint">from typing import Generator, Tuple

from legendre_symbol import legendre_symbol
from square_root import square_root


def elliptic_curve_points(a: int, b: int, p: int) -> Generator[Tuple[int, int], None, None]:
    """ 楕円曲線 y**2 = x**3 + a*x + b (mod p) の点を枚挙する。

    Args:
        a: int, b: int: 楕円曲線のパラメータ。y**2 = x**3 + a * x + b
        p (int): p > 3となる素数。

    Yields:
        x, y (int, int): 楕円曲線上の点(無限遠点を除く)

    Examples:
        >>> list(elliptic_curve_points(1, 3, 5))
        [(1, 0), (4, 1), (4, 4)]
        >>> list(elliptic_curve_points(1, 1, 5))
        [(0, 1), (0, 4), (2, 1), (2, 4), (3, 1), (3, 4), (4, 2), (4, 3)]
    """
    assert (4 * a**3 + 27 * b**2) % p != 0
    for x in range(p):
        y2 = (x**3 + a*x + b) % p
        legendre = legendre_symbol(y2, p)
        if legendre == 0:
            yield x, 0
        elif legendre == 1:
            y = square_root(y2, p)
            yield x, y
            yield x, -y % p
</pre>

<pre class="prettyprint">from legendre_symbol import legendre_symbol


def elliptic_curve_order(a: int, b: int, p: int) -> int:
    """ 楕円曲線 y**2 = x**3 + a*x + b (mod p) の群の位数を計算する。

    Args:
        a: int, b: int: 楕円曲線のパラメータ。y**2 = x**3 + a * x + b
        p (int): p > 3となる素数。

    Return:
        int: 群の位数

    Examples:
        >>> elliptic_curve_order(1, 3, 5)
        4
        >>> elliptic_curve_order(1, 1, 5)
        9
    """
    assert (4 * a**3 + 27 * b**2) % p != 0
    return p + 1 + sum(legendre_symbol(x**3 + a * x + b, p) for x in range(p))
</pre>

\(p\)が小さいうちは簡単に求められるが、\(p\)が大きくなると途端に手に負えなくなる。
そこでは、位数が取り得る値を教えてくれる。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
群\(E(\mathbb{F}_{p^k})\)の位数\(\sharp E(\mathbb{F}_{p^k})\)は次を満たす。
\begin{align*}
|\sharp E(\mathbb{F}_{p^k}) - (p^k + 1)| \le 2\sqrt{p^k}
\end{align*}
</div>

特に\(k=1\)のとき、つまり、\(E(\mathbb{F}_{p})\)の位数は、
\begin{align*}
p+1-2\sqrt{p} < \sharp E(\mathbb{F}_{p}) < p+1+2\sqrt{p}
\end{align*}
である。

群\(E(\mathbb{F}_7)\)に当てはめてみると
\begin{align*}
2.71\ldots < \sharp E(\mathbb{F}_7) < 13.29\ldots
\end{align*}
が得られ、位数が取り得るのは3から13であることが分かる。
ということは、位数16となる\(\mathbb{Z}_2 \times \mathbb{Z}_8\)や、位数18となる\(\mathbb{Z}_3 \times \mathbb{Z}_6\)とはならないことが分かる。
改めて整理すれば、群\(E(\mathbb{F}_7)\)が取り得る構造というのは、次に限られる。
<ul>
 <li> \(\mathbb{Z}_n\) ただし、\(3 \le n \le 13\)
 <li> \(\mathbb{Z}_2 \times \mathbb{Z}_2, \mathbb{Z}_2 \times \mathbb{Z}_4, \mathbb{Z}_2 \times \mathbb{Z}_6, \mathbb{Z}_3 \times \mathbb{Z}_3\)
</ul>

では、どの楕円曲線のときどの群となるのか？　一般には難しい問題であるが、\(E(\mathbb{F}_7)\)は高々\(7^2\)パターンしかないので調べるのは容易い(表\ref{table:EFF_7}{\((a,b)=(0,0),(1,2),(1,5),(2,2),(2,5),(4,2),(4,5)\)は楕円曲線の条件を満たさない。})。

\begin{table}[htb]\label{table:EFF_7}
\begin{center}
\caption{\(E(\mathbb{F}_7)\)の楕円曲線のパラメータ\((a,b)\)の違いによる群構造の変化}
\begin{tabular}{|l|l|l|}\hline
位数 & \(\mathbb{Z}_n\)                         & \(\mathbb{Z}_{d_1}\times\mathbb{Z}_{d_2}\) \\\hline\hline
3  & (0,4)                                    &                                          \\\hline
4  & (3,6), (5,6), (6,6)                      & (0,6)                                    \\\hline
5  & (1,1), (2,1), (4,1)                      &                                          \\\hline
6  & (1,3), (2,3), (3,3), (4,3), (5,3), (6,3) &                                          \\\hline
7  & (0,5), (3,5), (5,5), (6,5)               &                                          \\\hline
8  & (1,0), (2,0), (4,0)                      & (3,0), (5,0), (6,0)                      \\\hline
9  & (3,2), (5,2), (6,2)                      & (0,2)                                    \\\hline
10 & (1,4), (2,4), (3,4), (4,4), (5,4), (6,4) &                                          \\\hline
11 & (1,6), (2,6), (4,6)                      &                                          \\\hline
12 & (3,1), (5,1), (6,1)                      & (0,1)                                    \\\hline
13 & (0,3)                                    &                                          \\\hline
\end{tabular}
\end{center}
\end{table}

数学上の様態は理解が進んだかと思うが、これをプログラムに落とし込もうと思うと無限遠点\(O\)をどう扱うかなど、考える要素はいくつもある。
ここで紹介する実装方法は4種類である。
<ul>
 <li> [アフィン座標]\mbox{}\\
       \((x,y,z)\)の3つ組で管理し、楕円曲線上の点\((x,y)\)は\((x,y,1)\)、無限遠点は\((0,\pm1,0)\)とする。
 <li> [射影座標]\mbox{}\\
       \((X,Y,Z)\)の3つ組で管理し、無限遠点は\((0,1,0)\)とする。
       無限遠点でない射影座標\((X,Y,Z)\)は、アフィン座標\((X/Z,Y/Z,1)\)に対応する。
 <li> [修正射影座標]\mbox{}\\
       \((X,Y,Z)\)の3つ組で管理し、無限遠点は\((0,1,0)\)とする。
       無限遠点でない修正射影座標\((X,Y,Z)\)は、アフィン座標\((X/Z^2,Y/Z^3,1)\)に対応する。
 <li> [Montgomery座標]\mbox{}\\
       \((X,Z)\)の2つ組で管理し、無限遠点は\((0,0)\)とする。
       無限遠点でないMontogomery座標\((X,Z)\)は、アフィン座標\((X/Z,?,1)\)に対応する。
</ul>
アフィン座標は、上記数式の素朴な実装だ。
それに対して射影座標、修正射影座標は、逆元計算をなるべくしないようにしたいという意図がある。
Montgomery座標は、そもそも\(y\)座標を管理しない。
\(y\)座標に興味がない場合に使えて、素因数分解の高速化の際に触れる。

まずは、アフィン座標での実装例を見てみよう。

<pre class="prettyprint">import math
from typing import Tuple

from inverse_mod import inverse_mod
from n_times import n_times


class EllipticCurveAffine:
    def __init__(self, a: int, b: int, p: int):
        """ F_p上における楕円曲線を定義する。

        Args:
            p (int): p > 3となる整数。
            a: int, b: int: 楕円曲線のパラメータ。y**2 = x**3 + a * x + b
        """
        self.p = p
        self.a = a % p
        self.b = b % p
        assert (4 * self.a**3 + 27 * self.b**2) % p != 0

    def _discoverd_divisor(self, d: int) -> None:
        """ pを割り切る整数dを発見したとき、例外を発生させる。

        Args:
            d (int): pを割り切る整数
        """
        raise ValueError(
            f'p is composite number. p={self.p} is divisible by {d}', d)

    def is_zero(self, P: Tuple[int, int, int]) -> bool:
        """ 点Pが無限遠点かを判定する。

        Args:
            P(int, int, int): 点のx,y,z座標

        Returns:
            bool: Pが無限遠点の場合、True

        Examples:
            >>> ec = EllipticCurveAffine(3, 4, 11)
            >>> ec.is_zero((0, 1, 0)) # (0, 1, 0) は無限遠点
            True
        """
        x, y, z = P
        x %= self.p
        y %= self.p
        return x == 0 and (y == 1 or y == self.p - 1) and z == 0

    def add(self, P: Tuple[int, int, int], Q: Tuple[int, int, int]) -> Tuple[int, int, int]:
        """ 点PとQの和を計算する。

        Args:
            P(int, int, int), Q(int, int, int): 点のx,y,z座標

        Returns:
            (int, int, int): P + Q

        Examples:
            >>> ec = EllipticCurveAffine(6, 1, 7)
            >>> ec.add((0, 1, 1), (3, 2, 1))
            (1, 1, 1)
            >>> ec.add((3, 2, 1), (3, 5, 1))
            (0, 1, 0)
        """
        if self.is_zero(P):  # P + O = P
            return Q
        if self.is_zero(Q):  # Q + O = Q
            return P
        P_x, P_y, _ = P
        Q_x, Q_y, _ = Q
        P_x, P_y = P_x % self.p, P_y % self.p
        Q_x, Q_y = Q_x % self.p, Q_y % self.p
        if P_x == Q_x and P_y == self.p - Q_y:  # P + (-P) = O
            return (0, 1, 0)
        if P_x == Q_x and P_y == Q_y:
            inv = inverse_mod(2 * P_y, self.p)
            if inv is None:  # 逆元なし
                self._discoverd_divisor(math.gcd(2 * P_y, self.p))
            beta = (3 * P_x**2 + self.a) * inv
            x = beta**2 - 2 * P_x
            y = -P_y + beta * (P_x - x)
        else:
            inv = inverse_mod(Q_x - P_x, self.p)
            if inv is None:  # 逆元なし
                self._discoverd_divisor(abs(math.gcd(Q_x - P_x, self.p)))
            alpha = (Q_y - P_y) * inv
            x = alpha**2 - P_x - Q_x
            y = -P_y + alpha * (P_x - x)
        return (x % self.p, y % self.p, 1)

    def times(self, P: Tuple[int, int, int], n: int) -> Tuple[int, int, int]:
        """ Pのn倍を計算する

        Args:
            P(int, int, int): 点のx,y,z座標

        Returns:
            (int, int, int): [n]P

        Examples:
            >>> ec = EllipticCurveAffine(6, 1, 7)
            >>> ec.times((3, 2, 1), 2)
            (3, 5, 1)
            >>> ec.times((5, 4, 1), 5)
            (1, 1, 1)
        """
        return n_times(P, n, self.add)
</pre>

実装でネタバレをしているのだが、この楕円曲線に与える\(p\)は<strong>素数でなくともよい</strong>。
もちろん、\(p\)が素数でなければ群にはならないのだが、大抵の点で計算は問題なく行える。
計算が失敗し、群でないことが露わになる瞬間、うれしいことに一緒に素因数まで判明する。
素因数分解をしたい我々にとって願ってもない結果だ。
というわけで、これを素因数分解に使わない手はない。

<pre class="prettyprint">import math
import random

from sympy.ntheory import primerange

from EllipticCurveAffine import EllipticCurveAffine


def elliptic_curve_method(n: int, B: int) -> int:
    """ 楕円曲線法を用いて素因数分解を行う。

    Args:
        n (int): 素因数分解する整数。ただし、gcd(n,6)=1かつ累乗数でないとする。

    Returns:
        int: nの非自明な約数
             失敗した場合は、1

    Examples:
        >>> elliptic_curve_method(101 * 211, B=20)
        101
    """
    x, y = random.randint(0, n - 1), random.randint(0, n - 1)
    a = random.randint(0, n - 1)
    b = (y**2 - x**3 - a * x) % n
    ec = EllipticCurveAffine(a, b, n)
    P = (x, y, 1)
    for prime in primerange(2, B + 1):
        l = math.floor(math.log(B) / math.log(prime))
        try:
            P = ec.times(P, prime**l)
        except ValueError as e:
            return e.args[1]
    return 1
</pre>

楕円曲線法は、\(p-1\)法()に類似していることに気付いただろうか？　\(p-1\)法は\(p-1\)が\(B\)-smoothであるとき、素因数分解に成功したが、楕円曲線法も同じようなことが言える。
\(p-1\)法がなぜ\(p-1\)であったかと言えば、それが群の位数だったからである。
同様に、楕円曲線法も群の位数が\(B\)-smoothであれば素因数分解できる。
既に見たように、楕円曲線の群の位数はパラメータによって変化する。
つまり、楕円曲線のパラメータを動かすことによって、<strong>たまたま</strong>smoothな位数に巡り合えることができればよい。
また、楕円曲線を決めてから点を選ぼうとすると考えることが多くなるが、点を決めてからそれに合うように楕円曲線を選んでもよいので、そういう疑問も解決する。

さて、単純な改良は\(p-1\)法と同じように第2段階を適用することだ。
つまり、第1段階で\(B_1\)以下の素数\(p\)で、
\begin{align*}
Q = \left[\prod_{p} p^a\right] P
\end{align*}
と計算した\(Q\)を使って、\([p_1]Q, [p_2]Q, \ldots\)を計算していく。
ここで、\(p_1,p_2,\ldots\)は\(B_1\)以上\(B_2\)以下の素数だ。
しかも素数の差はそんなにパターンがないので、\(\Delta_2=[2]Q, \Delta_4=[4]Q,\ldots\)を予め計算しておき{2と3を除き、隣り合う素数の差は偶数になるので\(\Delta_1\)や\(\Delta_3\)は計算しなくて良い。}、
\begin{align*}
[p_i]Q = [p_{i-1}]Q + \Delta_{p_i-p_{i-1}}
\end{align*}
とすれば、(楕円曲線上での)加法1回で済む。
これは、\(k\)倍算するよりもはるかに高速だが、より高速化する方法を後に述べる。

また、アフィン座標ではなく、射影座標や修正射影座標で点を表すというのも1つの手だ。
しかし、更に突き詰めると、もはや\(y\)座標を考えなくても良いという結論に至る。
それがMontgomery座標である。
\(y\)座標を考えなくとも大丈夫なのかというと、実際、任意の加法ができないのだが、楕円曲線法で求められているのは\(k\)倍算であるので十分である。
しかも、楕円曲線のパラメータは\(A=1,B=0\)とした方が計算が簡略化される。
実際の計算は、\(P_1=(X_1,Z_1), P_2=(X_2,Z_2), P_{\pm}=P_1{\pm}P_2=(X_{\pm},Z_{\pm}),[2]P_1=(X_d,Z_d)\)とすると、
\begin{align*}
a_{24} &= \frac{C + 2}{4}\\
\alpha_{\pm} &= X_1 \pm Z_1\\
\beta_{\pm} &= X_2 \pm Z_2\\
X_+ &= Z_-(\alpha_-\beta_+ + \alpha_+\beta_-)^2\\
Z_+ &= X_-(\alpha_-\beta_+ - \alpha_+\beta_-)^2\\
X_d &= \alpha_+^2\alpha_-^2\\
Z_d &= (\alpha_+^2 - \alpha_-^2)(\alpha_-^2 + a_{24}(\alpha_+^2 - \alpha_-^2))
\end{align*}
で求められる{補助的に変数\(a_{24},\alpha_{\pm},\beta_{\pm}\)を導入した。特に\(a_{24}\)は\(C\)が決まった時点で以降は変わらないので、加算や2倍算時には定数として扱える。}。
見て分かる通り、\(P_1+P_2\)を計算するためには\(P_1-P_2\)を知っていなければならないので注意が必要だ。

次に、Montgomery座標で計算するとなったら、楕円曲線は\(y^2=x^3+Cx^2+x\)の中から選ぶことになるが、\(C\)をランダムに選ぶより良い方法について考えよう。
次の定理が知られている。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
楕円曲線\(E:y^2=x^3+C_{\sigma}x^2+x\)のパラメータ\(C_{\sigma}\)を\(\sigma\neq0,1,5\)に対して、
\begin{align*}
u &= \sigma^2 - 5\\
v &= 4\sigma\\
C_{\sigma} &= \frac{(v - u)^3(3u+v)}{4u^3v} - 2
\end{align*}
とすると、群\(E(\mathbb{F}_p)\)の位数は12で割り切れる。
さらに、Montgomery座標で\((u^3,v^3)\)と表される点を楕円曲線法の開始点としてよい。
</div>

よって、\(\sigma\)を選べば、良い曲線のついでに最初の点まで得られる。

<pre class="prettyprint">import math
import random
from typing import Optional

from sympy.ntheory import primerange

from inverse_mod import inverse_mod


def elliptic_curve_method_fast(n: int, *, B1: int,  D: int,
                               B2: Optional[int] = None,
                               sigma: Optional[int] = None) -> int:
    """ 各種の高速化手法を取り入れた楕円曲線法を用いた素因数分解。

    Args:
        n (int): 素因数分解する整数。ただし、gcd(n,6)=1。
        B1 (int), B2(int): 第1段階、第2段階の上限で偶数。B2が設定されない場合はB2=100*B1とする。
        D (int): キャッシュサイズ。大きい程メモリを使う
        sigma (int): 楕円曲線のパラメータ。6以上の整数。指定しない場合はランダム

    Returns:
        int: nの非自明な約数
             失敗した場合は、1

    Examples:
        >>> elliptic_curve_method_fast(1000037 * 1000253, B1=20, B2=200, D=100, sigma=40)
        1000253
    """
    B2 = B2 or 100 * B1

    def _add(P, Q, diff):
        """ Montgomery座標における加法 P+Q を計算する。ただし、diff=P-Q, A=1, B=0
        """
        P_x, P_z = P
        Q_x, Q_z = Q
        d_x, d_z = diff
        u = (P_x - P_z) * (Q_x + Q_z)
        v = (P_x + P_z) * (Q_x - Q_z)
        add, sub = u + v, u - v
        x = (d_z * add**2) % n
        z = (d_x * sub**2) % n
        return x, z

    def _double(P):
        """ Montgomery座標におけるPの2倍を計算する。ただし、A=1, B=0
        """
        P_x, P_z = P
        add, sub = (P_x + P_z)**2, (P_x - P_z)**2
        diff = add - sub
        x = (add * sub) % n
        z = (diff * (sub + a24 * diff)) % n
        return x, z

    def _times(P, k):
        """ Montgomery座標におけるPのk倍を計算する。ただし、A=1, B=0
        """
        Q = P
        R = _double(P)
        for bit in bin(k)[3:]:
            if bit == '1':
                Q, R = _add(R, Q, P), _double(R)
            else:
                Q, R = _double(Q), _add(Q, R, P)
        return Q

    def _sequence(*, s_1, delta, k=None, s_0=None, s_2=None):
        """ s_1, s_2, ..., s_k を返す
        ただし、s_0 = s_1 - delta, s_1 = s_1, s_2 = s_1 + delta, s_3 = s_1 + 2delta
        """
        def _next(pre, current):
            return current, _add(current, delta, pre)
        yield s_1
        pre, current = _next(s_0, s_1) if s_0 is not None else (s_1, s_2)
        yield current
        k = k or B2  # k is None の場合は十分大きな値を設定する
        for _ in range(2, k):
            pre, current = _next(pre, current)
            yield current

    sigma = sigma or random.randint(6, n - 1)
    u = (sigma**2 - 5) % n
    v = (4 * sigma) % n
    diff = v - u
    Q = u_3, _ = pow(u, 3, n), pow(v, 3, n)
    C = (pow(diff, 3, n) * (3 * u + v) * inverse_mod(4 * u_3 * v, n) - 2) % n
    a24 = (C + 2) * inverse_mod(4, n) % n
    # 楕円曲線 y**2 = x**3 + C * x**2 + x を用いる

    # stage 1
    for prime in primerange(2, B1 + 1):
        l = math.floor(math.log(B1) / math.log(prime))
        Q = _times(Q, prime**l)
    assert Q[1] != 0 # Q[1] == 0 は実用上滅多に発生しないが、この場合はB1が大きすぎた
    g = math.gcd(Q[1], n)
    if 1 < g < n:
        return g

    # stage 2
    s_1 = _double(Q)
    # S_i = [2(i+1)]Q
    S = list(_sequence(s_1=s_1, s_2=_double(s_1), delta=s_1, k=D))
    beta = [(x * z) % n for x, z in S]
    g = 1
    B = B1 - 1
    seq = _sequence(s_0=_times(Q, B - 2 * D), s_1=_times(Q, B), delta=S[D-1])
    for r in range(B, B2, 2 * D):
        R_x, R_z = next(seq)
        alpha = (R_x * R_z) % n
        for q in primerange(r + 2, r + 2 * D + 1):
            delta = (q - r) // 2 - 1
            d_x, d_z = S[delta]
            f = (R_x - d_x) * (R_z + d_z) - alpha + beta[delta]
            g = (g * f) % n
    g = math.gcd(g, n)
    if 1 < g < n:
        return g
    else:
        return 1  # 失敗
</pre>
</body></html>