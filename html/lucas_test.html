
<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>lucas_test</h1>群\(G\)の元\(a\in G\)について、\(a, a^1, a^2,\ldots\)を眺めているとどうなるだろうか。
例えば、整数は加法について群を成すから、\(a=3\)とすると\(3,6,9,\ldots\)と続く。
ここでは、\(n\)を法とする既約剰余類\(\mathbb{Z}_n^*\)を主に考えることにしよう。
\(n=4,a=3\)とすると、\(a^1=3,a^2=1,a^3=1\ldots\)というように\(1\)と\(3\)を交互に繰り返す。
一方、\(n=5,a=2\)ならば\(a^1=2,a^2=4,a^3=3,a^4=1\ldots\)となり、\(1\)から\(n-1\)までの数がモレなくダブりなく現れる。
これについて考えるにあたって、位数という概念を導入する。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
群\(G\)の元\(a\in G\)の位数は、\(a^s = 1\)となるような最小の正整数\(s\)であり、\(\mbox{ord}(a)=s\)と書く。
そのような正整数が存在しない場合は\(0\)と定義する。
</div>

法\(n\)の既約剰余類\(\mathbb{Z}_n^*\)で考えるなら、\(a^s \equiv 1 \pmod{n}\)を満たす最小の正整数\(s\)と言い換えても良い。
群の位数()と元の位数は混同しやすいが、まったく別物である。

<ul>
 <li> 既約剰余類\(\mathbb{Z}_{5}^*\)において、\(a=3\)の位数は\(4\)である。なぜなら、法\(5\)において、\(a^1\equiv3,a^2\equiv4,a^3\equiv2,a^4\equiv1\)となるからである。
 <li> 同じ既約剰余類\(\mathbb{Z}_{5}^*\)でも、\(a=2\)の位数は\(2\)となる。なぜなら、法\(5\)において、\(a^1\equiv4,a^2\equiv1\)となるからである。
</ul>

上記の例で見るように、群が同じでも元によって位数は異なる。
ここでは特に、元の位数が最大となるような(換言すれば、元の位数が群の位数に一致するような)元に興味がある。
そのような元を原始根と呼ぶ。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
法\(n\)の既約剰余類\(\mathbb{Z}_n^*\)において、位数が\(\varphi(n)\)となる\(g\in\mathbb{Z}_n^*\)を原始根と呼ぶ。
</div>

同じことだが、\(g\)が原始根ならば、\((g,g^2,g^3,\ldots,g^{\varphi(n)})\)の中に、ダブりもモレもなく、\(\mathbb{Z}_n^*\)の元が登場する。
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)\;
<ul>
 <li> \(g=2\)は\(n=5\)を法とする原始根である。実際、\(g=2,g^2=4,g^3=3,g^4=1\)である。
 <li> \(g=3\)は\(n=49\)を法とする原始根である。
</ul>
</div>

素数判定において重要となる事実は次である。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
次のいずれかのとき、かつそのときのみ、\(n\)を法とする原始根が存在する。
<ol>
 <li> \(n=2\)または\(n=4\)
 <li> \(p\)を奇素数、\(e\ge1\)とするとき、\(n=p^e\)または、\(n=2p^e\)
</ol>
</div>

つまり、原始根を見つけること、それ即ち素数であると判明することなのである。
いや、素数でなくとも原始根が見つかることはあるではないか、というのは正しい指摘である。
そこで、Fermatの小定理()も援用しよう。
Fermatの小定理によれば、任意の\(n\)について
\begin{align*}
a^{\varphi(n)} \equiv 1 \pmod{n}
\end{align*}
なのであった。
一方で、\(n\)が素数のとき、かつそのときのみ\(\varphi(n)=n-1\)なのである。
\begin{align*}
a^{n-1} \equiv 1 \pmod{n}
\end{align*}
は、\(n\)が素数ならば当然成り立つが、合成数\(n\)を法とする原始根では成り立たない。
よって、
<ol>
 <li> ランダムに\(a\in\mathbb{Z}_n^*\)を選ぶ
 <li> Fermatテストで1でなければ合成数
 <li> \(a\)が原始根ならば素数。そうでなければ1に戻る。
</ol>
という手順で素数判定ができそうだ。
これが、<strong>Lucasテスト</strong>(Lucas primality test)だ。
原始根かどうかを判定する部分を天下りで与えるが、とりあえず実装を与える。

<pre class="prettyprint">import random

from sympy import factorint


def lucas_primality_test(n: int, k: int = 10) -> str:
    """ Lucasの定理を用いて、n > 2が素数かを判定する。

    Args:
        n (int): 素数判定する対象の自然数
        k (int): 試行回数。nが素数で十分大きい場合、
                 1回の試行で素数と判定できる確率は、少なくとも 1 / (2 ln ln n)

    Returns:
        string: 'prime number'       = nは素数
                'composite number'   = nは合成数
                'possibly composite' = nはおそらく合成数

    Examples:
        >>> lucas_primality_test(93)
        'composite number'
        >>> lucas_primality_test(101)
        'prime number'
    """
    qs = [*factorint(n - 1)]
    for _ in range(k):
        a = random.randrange(2, n)
        if pow(a, n - 1, n) != 1:
            return 'composite number'
        if all(pow(a, (n - 1) // q, n) != 1 for q in qs):
            return 'prime number'
    return 'possibly composite'
</pre>

数式で書くなら、次のようになる。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
整数\(a,n\)が次を満たすとき、\(n\)は素数である。
\begin{align*}
\begin{cases}
a^{n-1} &\equiv 1 \pmod{n}\\
a^{(n-1)/q} &\not\equiv 1 \pmod{n}
\end{cases}
\end{align*}
ただし、\(q\)は、\(n-1\)の任意の素因数とする。
</div>

簡単な例で確かめてみよう。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)
\(n=97\)のとき、\(n-1=2^5\times3\)であるから、素因数は\(2\)と\(3\)がある。
\(a=7\)とすると、
\begin{align*}
\begin{cases}
7^{97-1} &\equiv 1 \pmod{97}\\
7^{(97-1)/2}  \equiv 96 &\not\equiv 1 \pmod{97}\\
7^{(97-1)/3}  \equiv 35 &\not\equiv 1 \pmod{97}
\end{cases}
\end{align*}
となり、\(97\)は素数である。
</div>

一方で、同じ条件でも\(a=3\)のときは、
\begin{align*}
\begin{cases}
3^{97-1} &\equiv 1 \pmod{97}\\
7^{(97-1)/2}  &\equiv 1 \pmod{97}\\
7^{(97-1)/3}  \equiv 35 &\not\equiv 1 \pmod{97}
\end{cases}
\end{align*}
となるから、どんな\(a\)でもよいわけではないことが分かる。
これは既に見たように、すべてが原始根というわけではないからだ。
では、どのくらい原始根が存在するのだろうか？　Lucasテストがどのくらい繰り返す必要があるかは、原始根が\(\mathbb{Z}_n^*\)の中にどれくらい存在するのかによって決まるから重要である。
それには次の評価が有用である。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
奇素数\(p\)を法とする原始根の個数は\(\varphi(p-1)\)個である。
一般に、\(\mathbb{Z}_p^*\)の中で、位数が\(r\)となる元は\(\varphi(r)\)個存在する。
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)\;
<ul>
 <li> \(p=5\)のとき、
  <ul>
   <li> 位数4の元は2,3の2個(\(=\varphi(4)\))
   <li> 位数2の元は4の1個(\(=\varphi(2)\))
   <li> 位数1の元は1の1個(\(=\varphi(1)\))
  </ul>
  <li> \(p=13\)のとき、
  <ul>
   <li> 位数12の元は2,6,7,11の4個(\(=\varphi(12)\))
   <li> 位数6の元は4,10の2個(\(=\varphi(6)\))
   <li> 位数4の元は5,8の2個(\(=\varphi(4)\))
   <li> 位数3の元は3,9の2個(\(=\varphi(3)\))
   <li> 位数2の元は12の1個(\(=\varphi(2)\))
   <li> 位数1の元は1の1個(\(=\varphi(1)\))
  </ul>
</ul>
</div>

そう言われても、\(\varphi(n-1)\)はどのくらいなのだ、という疑問が湧き出てくる。
そこで次の事実である。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(n\)を十分大きい素数とする。\(n\)を法とする原始根は\(n/(2\ln\ln{n})\)を超える。
</div>

よって、\(n\)が十分大きければ、\(2\ln\ln{n}\)以下の試行で原始根を見つけられると期待できる。
また、\(\mathbb{Z}_p^*\)に原始根が必ず存在するという事実は、証明にも利用できる。
試しにFermatの小定理を証明してみよう。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)
\(p\)を素数とする。
任意の\(a\in\mathbb{Z}_p^*\)は、原始根\(g\in\mathbb{Z}_p^*\)と\(k\in\mathbb{Z}\)で、\(a=g^k\)と書けることに注意しよう。
\begin{align*}
a^{p-1} &= (g^k)^{p-1}\\
 &= (g^{p-1})^k\\
 &= 1^k \\
 &= 1
\end{align*}
となり、題意は示された。
</div>

他にもWilsonの定理も原始根を使って証明できる{なお、Wilsonの定理を使って素数判定を行うこともできるが、計算コストが高すぎて小さな数でさえも実用的ではない。}。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(p\)が素数であるとき、かつそのときのみ、次が成り立つ。
\begin{align*}
(p-1)! \equiv -1 \pmod{p}
\end{align*}
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)
十分条件のみ示す。

\(p\)を奇素数とする(\(p=2\)のときは明らか)。
定理は\(\mathbb{Z}_p^*\)の総積が\(-1\)に一致すると主張するが、任意の\(a\in\mathbb{Z}_p^*\)は、原始根\(g\in\mathbb{Z}_p^*\)と\(k\in\mathbb{Z}\)で\(a=g^k\)と書け、さらにこの\(k\)と\(a\)は1対1に対応する。
\begin{align*}
\prod_{a \in \mathbb{Z}_p^*} a &= \prod_{k=0}^{p-1} g^k\\
 &= g^{\sum_{k=0}^{p-1}k}\\
 &= g^{(p-1)(p-2)/2} = (g^{(p-1)/2})^{p-2}\\
 &= (-1)^{p-2} = -1
\end{align*}
となり、題意は示された。
途中、\(g^{(p-1)/2}=-1\)となることは、\(g^{p-1}=1\)になることからも了解できる。
また、\(p-2\)は奇数であることにも注意する。
</div>

もう一つ懸念があるとすれば、Lucasテストを実行するには\(n-1\)の素因数分解が明らかでなければならないという所にある。
では、自前で素因数分解したが、これが常に簡単にできるとは限らない。
ふつうは、\(2^s+1\)などの\(n-1\)の素因数が明らかな整数の素数判定に用いられる。
次節以降では、特定の形に特化した素数判定法を紹介していくが、Lucasテストは最も初歩的で汎用的なアルゴリズムと言える。

ここからは原始根を求めるアルゴリズムについて、その理屈を説明していこう。
冒頭で説明したきり、登場しないから忘れられているかもしれないが、元の位数について、基本的な性質をまとめておこう。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
有限群\(G\)において、元\(a,b\in G\)の位数\(\mbox{ord}(a), \mbox{ord}(b)\)は、次を満たす。
<ol>
<li> \(a^1,a^2,\ldots,a^{\mbox{ord}(a)}\)はすべて相異なる。
<li> \(a^j=1 \iff \mbox{ord}(a) \mid j\)
<li> \(\mbox{ord}(a) = \mbox{ord}(a^{-1})\)
<li> \(\gcd(\mbox{ord}(a), \mbox{ord}(b))=1\)ならば、\(\mbox{ord}(ab)=\mbox{ord}(a)\mbox{ord}(b)\)
</ol>
</div>

原始根とは、元の位数が群の位数に一致するような元であることを思い出せば、元が与えられたとき、その元の位数を求めることは即ち原始根判定かを判定しているに等しい。
それならば、元の位数を得るには始めて\(1\)になるまで\(a^0, a^1, a^2, \ldots\)を順に計算する方法が考えられるだろう。
しかし、元の位数となる数の候補は実はもっと少ない。
まずは、群論を学ぶとLagrangeの定理の系として説明される、次の事実を確認する。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
有限群\(G\)について、\(G\)の任意の元\(a\in G\)の位数は、群\(G\)の位数を割り切る。
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)
法\(n=97\)の既約剰余類\(\mathbb{Z}_{97}^*\)において、群の位数は\(\varphi(n)=96\)である。
\(a=3\)の位数は\(48\)であり、\(96\)を割り切る。一方、\(a=7\)の位数は\(96\)であり、\(96\)を割り切る。
</div>

元\(a \in \mathbb{Z}_n^*\)の位数の求め方は次のようになる。

<pre class="prettyprint">from sympy import factorint

from totient_function import totient_function


def n_order(a: int, n: int) -> int:
    """ 法nにおけるaの位数を求める。
    つまり、a^s = 1 (mod n)を満たす最小のsを求める。

    Args:
        a (int): 整数
        n (int): 正整数

    Returns:
        int: 法nにおけるaの位数

    Examples:
        >>> n_order(3, 11)
        5
        >>> n_order(5, 12)
        2
    """
    group_order = totient_function(n)
    order = group_order
    for prime in [*factorint(group_order)]:
        while pow(a, order // prime, n) == 1:
            order //= prime
    return order
</pre>

素数\(p\)の原始根を求める方法は、位数を求めるアルゴリズムと考え方は同じで、\(p-1\)以外の約数で\(a^{m}=1\)となるならそれは原始根ではない、として棄却できる。
原始根はそれなりの数があるので、原始根に巡り合うまでランダムに\(a\)を選んでも、実用上すぐに見つかる。
一方で、原始根を見つける決定的な多項式時間アルゴリズムは未だ知られていない。

最後に、\(p^e\)における原始根の求め方を紹介しよう。
基本的には既に紹介した素数の場合の考え方と同じだ。
単なる好みの問題で、原始根の候補をランダムに選ぶのではなく、2から順に調べている。
さらに、指数が1より大きい場合は、次の事実も考慮しなければならない。

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
奇素数\(p\)、\(p\)を法とする原始根を\(g\)、\(1\)より大きい任意の整数\(e>1\)とする。
次の式を満たすとき、\(g^e\)を法とする原始根は\(g\)である。
逆に満たさないとき、\(g^e\)を法とする原始根は\(g+p\)である。
\begin{align*}
g^{p-1} \not\equiv 1 \pmod{p^2}
\end{align*}
</div>

これで、任意の原始根を求めることが可能である。

<pre class="prettyprint">from sympy.ntheory import factorint


def primitive_root(p: int, e: int) -> int:
    """ p^eを法とする原始根を返す。

    Args:
        p (int): 奇素数
        e (int): 1以上の整数

    Returns:
        g (int): p^eを法とする原始根

    Examples:
        >>> primitive_root(7, 2)
        3
    """
    qs = [*factorint(p - 1)]  # p - 1の素因数リスト
    g = 2
    while not all(map(lambda q: pow(g, (p - 1) // q, p) != 1, qs)):
        g += 1
    if e == 1:
        return g
    if pow(g, p - 1, p**2) == 1:
        return g + p
    return g
</pre>
</body></html>