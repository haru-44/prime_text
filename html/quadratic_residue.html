<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=py&skin=sunburst"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>quadratic_residue</h1>
<p>整数の世界において平方数とは、整数の2乗の形で表される数である。
例えば、\(4, 9, 16, 25\)は平方数である。
同じように、剰余の世界でも平方数を考えることができる。
ただし、剰余の世界では「平方数」ではなく「平方剰余」と呼んでいる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
整数\(a\)と正整数\(n\)について、\(x^2 \equiv a \pmod{n}\)を満たす整数\(x\)が存在するとき、\(a\)を\(n\)を法とする平方剰余と呼ぶ。
逆に\(x\)が存在しないとき、\(a\)を\(n\)を法とする平方非剰余と呼ぶ。
</div>

<p>これ以降は、素数\(p\)で考えていく。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
素数\(p\)において、\(a\)が\(p\)を法とする平方剰余ならば、\(x^2\equiv a\pmod{p}\)となるような\(x\)は、\(\mathbb{Z}_p^*\)上に必ずちょうど2つ存在する。
</div>

<p>という事実から考察を進めていこう。
整数や実数の世界では当たり前のことだが、その理屈は\(\mathbb{Z}_p^*\)上でも同じで、\(x\)が\(x^2\equiv a\pmod{p}\)となるならば、\(-x\)も\(a\)の解であり、それ以外には存在しない。
そう言われても、狐につままれたような感じだろうから、例を見てみる。
</p>
<p>\(p=5\)のとき
\begin{table}[h]
  \begin{tabular}{|c||c|c|c|c|}\hline
    \(a\) & 1 & 2 & 3 & 4 \\\hline
    \(a^2\) & 1 & 4 & 4 & 1 \\\hline
  \end{tabular}
\end{table}
</p>
<p>となるから、(下段に現れる)1,4が平方剰余で、2,3が平方非剰余である。
もう少し大きい、\(p=11\)のときも試してみよう。
\begin{table}[h]
  \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}\hline
    \(a\) & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\\hline
    \(a^2\) & 1 & 4 & 9 & 5 & 3 & 3 & 5 & 9 & 4 & 1 \\\hline
  \end{tabular}
\end{table}
</p>
<p>この場合も、1,3,4,5,9の5つが平方剰余で、残りの2,6,7,8が平方非剰余である。
このような表に書き出してみると分かるが、\(p=11\)の場合は、5と6を境界として鏡写しになったように\(a^2\)が配されている。
これは、解が\(\pm a\)であることを反映しているが、もう少し考察すると次の事実が明らかになる。
ここで、\(\mathbf{QR}_p\)は\(\mathbb{Z}_p^*\)上の平方剰余の集合、\(\mathbf{QNR}_p\)は\(\mathbb{Z}_p^*\)上の平方非剰余の集合とする。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\begin{align*}
\sharp\mathbf{QR}_p = \sharp\mathbf{QNR}_p = \frac{p-1}{2}
\end{align*}
</div>

<p>つまり、平方剰余の元と平方非剰余の元は、\(\mathbb{Z}_p^*\)上にちょうど半分ずつ存在しているのだ。
これは既に例示した\(p=5\)と\(p=11\)の場合でも確認できて、それぞれ平方剰余の元は2個と5個あることが分かる。
</p>
<p>平方剰余の簡単な確認になるが、次の事実も示してみよう。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)\;
<ol>
 <li> \(a,b\in\mathbf{QR}_p\)ならば\(ab\in\mathbf{QR}_p\)
 <li> \(a\in\mathbf{QR}_p, b\in\mathbf{QNR}_p\)ならば\(ab\in\mathbf{QNR}_p\)
 <li> \(a,b\in\mathbf{QNR}_p\)ならば\(ab\in\mathbf{QR}_p\)
</ol>
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)\;
<ol>
 <li> \(a,b\in\mathbf{QR}_p\)であるから、\(a\equiv s^2\pmod{p}, b\equiv t^2\pmod{p}\)となる元\(s,t\in\mathbb{Z}_p^*\)が存在する。よって、\(ab\equiv s^2t^2\equiv(st)^2\pmod{p}\)も平方剰余である。
 <li> \(a\in\mathbf{QR}_p, b\in\mathbf{QNR}_p\)のとき、\(ab\in\mathbf{QR}_p\)であると仮定すると、\(a\equiv s^2\pmod{p}, ab\equiv t^2\pmod{p}\)となる元\(s,t\in\mathbb{Z}_p^*\)が存在する。\(a\equiv s^2\pmod{p}\)を代入すると、\(s^2b\equiv t^2\pmod{p}\iff b\equiv (t/s)^2\pmod{p}\)を得るが、\(b\)が平方剰余となって矛盾。
 <li> ある\(c \in \mathbf{QNR}_p\)について、\(f(x)=cx\)を考える。\(\mathbb{Z}_p^*\)が群であるから、\(f:\mathbb{Z}_p^*\to\mathbb{Z}_p^*\)は全単射である。\(x \in \mathbb{Z}_p^*\)のうち、\(x\in\mathbf{QR}_p\)は\(cx\in\mathbf{QNR}_p\)に移るので、残る\(x\in\mathbf{QNR}_p\)は(の事実から)\(cx\in\mathbf{QR}_p\)に移るしかない。よって、題意は示された。
</ol>
</div>

<p>次に、いちいち「\(a\)を\(p\)を法とする平方非剰余」等と言うのは面倒くさいので、今後はLegendre記号と呼ばれる記号で表すことにする。
しかし慣習とはいえ、分数にしか見えないこの記号は混乱を招く。
しかも、後で紹介するJacobi記号()も同じように書くものだから、混乱の度合いは増すのだが、そこに文句を言っても仕方がないので諦めよう。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
Legendre記号\(\left(\frac{a}{p}\right)\)は、整数\(a\)及び奇素数\(p\)について
\begin{align*}
\left(\frac{a}{p}\right) =
\begin{cases}
0, &\mbox{if }a \equiv 0 \pmod{p}\\
1, &\mbox{if }\exists x \mbox{ s.t. } x^2 \equiv a \pmod{p}\\
-1, &\mbox{otherwise}
\end{cases}
\end{align*}
と定義される。
</div>

<p>Legendre記号を使えば、例えば、の1は、
\begin{align*}
\left(\frac{a}{p}\right)\left(\frac{b}{p}\right) = \left(\frac{ab}{p}\right)
\end{align*}
と書き直せる{厳密には\(a\equiv0\pmod{p}\)のケースを議論していないが、脇に除ける。}。
</p>
<p>これまで平方剰余の性質について見てきたが、整数\(a\)と奇素数\(p\)が与えられたとき、\(a\)が\(p\)を法とする平方剰余か否かを判別する(別の言い方をすれば、Legendre記号\(\left(\frac{a}{p}\right)\)の値を得る)にはどうしたらよいだろうか。
愚直には、1～\(p-1\)までの数をそれぞれ2乗し、\(a\)になるかを確認すればよい。
\(p\)が小さいうちは何とかなるかもしれないが、\(p\)が大きくなると手に負えそうにない。
実はわりと簡単に計算することができる次の方法が知られていて、それが<strong>Eulerの規準</strong>(Euler's criterion)とも呼ばれている。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
Legendre記号\(\left(\frac{a}{p}\right)\)は、整数\(a\)及び奇素数\(p\)について、次の式で計算できる。
\begin{align*}
\left(\frac{a}{p}\right) \equiv a^{(p-1)/2} \pmod{p}
\end{align*}
</div>

<p>既に述べたように、\(\mathbb{Z}_p^*\)の元は、\(p\)を法として平方剰余か平方非剰余かで丁度2つに分けられ、どちらが多くも少なくもない。
実は\(p\)を法とする平方剰余(あるいは平方非剰余)を1つ示せ、という問題に答える確定的アルゴリズムは知られていないのだが、個数は分かっているので、ランダムに選んで平方剰余かを判定すれば、\(1/2\)の確率で所望の結果が得られるわけだ。
実用的には数回試行すれば事足りるので十分効率的であると言える。
</p>
<p>余談となるが、平方剰余と平方剰余を掛けたものもまた平方剰余であるため、平方剰余の集合\(\mathbf{QR}_p\)は乗法について群を成す。
一方、平方非剰余の集合\(\mathbf{QNR}_p\)は群にならないが、これがなぜかというのは群の良い復習になる。
\(1\)は常に平方剰余であり、つまり、平方非剰余の集合に単位元が存在しないと言うことは、群の定義を満たさないのである。
</p>
<p>さて、Legendre記号を求めるアルゴリズムは、を素直に実装すると、次の通りとなる。
</p>
<pre class="prettyprint">def legendre_symbol(a: int, p: int) -> int:
    """ Legendre記号(a / p)を計算する。

    Args:
        a (int): 整数
        p (int): 奇素数。
                 仮に奇素数でない場合でも、エラーなく計算するが、結果は保証されない。

    Returns:
        int: 1  = aはpを法として平方剰余
             -1 = aはpを法として平方非剰余
             0  = aはpで割り切れる

    Examples:
        >>> legendre_symbol(2, 5)
        -1
        >>> legendre_symbol(4, 7)
        1
    """
    ans = pow(a, (p - 1) // 2, p)
    if ans + 1 == p:
        return -1
    return ans
</pre>

<p>以上のように、素数を法とする平方剰余の判定は簡単に行うことができるのである。
平方剰余の理論は、次に示す平方剰余の相互法則によって、1つの頂点を迎える。
後に、三次や四次の相互法則に拡張され、より一般的な相互法則を見出す作業は、19世紀の数学者にとって大きな目標となった。
代数的整数論における記念碑的定理である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(p,q\)を2より大きい素数とする。
このとき、次が成り立つ。
\begin{align*}
\left(\frac{p}{q}\right)\left(\frac{q}{p}\right) = (-1)^{\frac{p-1}{2}\frac{q-1}{2}}
\end{align*}
</div>

<p>普通の教科書ならば、順を追って証明するのだが、ここでは紹介のみに留め、次に進もう。
素数を法とする平方剰余の判定ができたのだから、次は整数について同じようにと考えることもできる。
しかし、これから進む道は別の道である。
Legendre記号を拡張することによって、素数を法とする平方剰余の判定を更に高速化できないか、という方向を考えるのである。
</p>
<p>まず、Jacobi記号を定義する。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
Jacobi記号\(\left(\frac{a}{m}\right)\)は、整数\(a\)及び奇数\(m\)について
\begin{align*}
\left(\frac{a}{m}\right) = \prod_{i = 1}^r \left(\frac{a}{p_i}\right)^{e_i}
\end{align*}
と定義される。
ただし、\(m=p_1^{e_1}\cdot\cdots\cdot p_r^{e_r}\)と素因数分解できるとする。
また、右辺はLegendre記号である。
</div>

<p>Legendre記号とJacobi記号で、同じ記号を使うものだから混乱しやすい。
その点は、どうしようもないことなので、「同じ記号であっても別物である」ということを念頭に置いて理解する必要がある。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)
\begin{align*}
\left(\frac{4}{45}\right) &= \left(\frac{4}{3}\right)^2\left(\frac{4}{5}\right)\\
&= (1)^2(1) = 1
\end{align*}
</div>

<p>Jacobi記号は、Legendre記号の積として定義されたことを思い出せば、計算結果は\(-1,0,1\)のいずれかになるはずである。
そうすると、(Legendre記号と同様に)Jacobi記号が平方剰余か否かを表しているように早合点してしまいがちだ。
しかし、<strong>Jacobi記号の値が平方剰余かどうかを示すわけではない</strong>ということは予め断っておく。
Jacobi記号とLegendre記号の関係を知るには、次の2つの性質が重要である。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(m\)が素数ならば、Jacobi記号\(\left(\frac{a}{m}\right)\)とLegendre記号\(\left(\frac{a}{m}\right)\)は、任意の\(a\)について一致する。
</div>

<p>素数ならばLegendre記号と一致する、ということは定義から一目瞭然であるが、言い方を変えれば、Legendre記号が定義する範囲内においてはJacobi記号を代用しても構わない、と考えることもできる。
もう1つは、Jacobi記号の値が平方剰余かどうかを示すわけではないということだ。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
整数\(a\)及び奇数\(m\)について、Jacobi記号\(\left(\frac{a}{m}\right)\)が\(-1\)になるとき、\(a\)は\(m\)を法として平方非剰余であるか\(a\)と\(m\)は互いに素でない。
</div>

<p>奇数の合成数の時にも、一定の場合平方非剰余の判定に利用できることが分かるが、この命題の逆、つまり、Jacobi記号が1になったからと言って、平方剰余であるとは限らない。
実際、\(2\)は\(15\)を法として平方非剰余であるが、
\begin{align*}
\left(\frac{2}{15}\right) &= \left(\frac{2}{3}\right)\left(\frac{2}{5}\right)\\
&= (-1)(-1)\\
&= 1
\end{align*}
となる。
何度も確認してそろそろ鬱陶しいと思うが、左辺はJacobi記号で、右辺はLegendre記号である。
</p>
<p>そういうわけで、Jacobi記号が平方剰余判定に対して、そこまで強力な武器ではないように見えるし、Jacobi記号の計算するにしても\(m\)の素因数分解を行う必要があるように見える。
しかしJacobi記号は、\(m\)の素因数分解を行うことなく計算することができる。
それを説明するためには、Jacobi記号の性質について理解する必要がある。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
1より大きい奇数\(n,m\)および整数\(a,b\)について次が成り立つ。
<ol>
<li> \(a\equiv b \pmod{n}\)ならば、\(\left(\frac{a}{n}\right)=\left(\frac{b}{n}\right)\)
<li> \(\left(\frac{ab}{n}\right)=\left(\frac{a}{n}\right)\left(\frac{b}{n}\right)\)
<li> \(\left(\frac{a}{nm}\right)=\left(\frac{a}{n}\right)\left(\frac{a}{m}\right)\)
</ol>
</div>

<p>更に、Jacobi記号にも平方剰余の相互法則が成り立つ。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(n,m\)を互いに素な1より大きい奇数とする。
このとき、次が成り立つ。
\begin{align*}
\left(\frac{m}{n}\right)\left(\frac{n}{m}\right) = (-1)^{\frac{n-1}{2}\frac{m-1}{2}}
\end{align*}
</div>

<p>以上の性質を用いると、Jacobi記号は次のアルゴリズムで計算できる。
</p>
<pre class="prettyprint">def jacobi_symbol(a: int, m: int) -> int:
    """ Jacobi記号(a / m)を計算する。

    Args:
        a (int): 整数
        m (int): 奇数

    Returns:
        int: Jacobi記号(a / m)の値

    Examples:
        >>> jacobi_symbol(2, 15)
        1
        >>> jacobi_symbol(5, 11)
        1
    """
    if a == 0:
        return 1 if m == 1 else 0
    if a % 2 == 1:
        sign = -1 if a % 4 == m % 4 == 3 else 1
        return sign * jacobi_symbol(m % a, a)
    sign = -1 if m % 8 == 3 or m % 8 == 5 else 1
    return sign * jacobi_symbol(a // 2, m)
</pre>

<p>は、より高速に計算できる。
そして、より素数の範囲においてはLegendre記号とJacobi記号は一致する。
ならば、Legendre記号\(\left(\frac{a}{p}\right)\)を計算する際は、を使った方がよい、というのがJacobi記号を導入した1つの成果である。
一方で、別の見方もできる。
\(m\)が素数のとき、\(\left(\frac{a}{m}\right)\)は、もでも同じ結果になるが、\(m\)が合成数のとき<strong>一致しないこともある</strong>。
素数と合成数で異なる挙動を示すということは、素数判定に使えるのではないかというアイディアが浮かぶ。
</p>
<p><strong>Solovay-Strassenテスト</strong>(Solovay-Strassen primality test)は、Legendre記号とJacobi記号の振舞いの違いに着目する{Legendre記号は合成数に対して定義されていないため、正確を期すならば、「Legendre記号を求めるための計算とJacobi記号の振舞いの違い」と言うべきだろうが、その点は甘受頂きたい。}。
\(n\)が素数の場合、この2つは常に一致するが、合成数の場合はそうではない。
\(a\)の値によって一致することもあるし、一致しないこともある。
この一致する\(a\)と一致しない\(a\)は、丁度半分ずつ存在するので、\(a\)をランダムに選べば\(1/2\)の確率で合成数であることが分かるのである。
</p>
<pre class="prettyprint">import random

from jacobi_symbol import jacobi_symbol
from legendre_symbol import legendre_symbol


def solovay_strassen_test(n: int, k: int = 10) -> str:
    """ Solovay-Strassenテストを用いて、n>2が素数かを判定する。

    Args:
        n (int): 素数判定する対象の奇数
        k (int): 試行回数。既定値を10としたが、特に意味はない。
                 合成数だが'probable prime'と判定する確率は高々2^{-k}

    Returns:
        string: 'composite number' = nは合成数
                'probable prime'   = nはおそらく素数

    Examples:
        >>> solovay_strassen_test(101)
        'probable prime'
        >>> solovay_strassen_test(111)
        'composite number'
    """
    for _ in range(k):
        a = random.randrange(2, n)
        if jacobi_symbol(a, n) != legendre_symbol(a, n):
            return 'composite number'
    return 'probable prime'
</pre>

<p>なぜ、 \(n\)が合成数の場合、Legendre記号とJacobi記号が一致する\(a\)が、丁度全体の半分存在するのであろうか。
\(\mathcal{S}\)をLegendre記号とJacobi記号が一致する\(a\)の集合とする。
つまり、
\begin{align*}
\mathcal{S} = \left\{a \in \mathbb{Z}_n^* : \left(\frac{a}{n}\right) \equiv a^{(n-1)/2} \pmod{n}\right\}
\end{align*}
とする。
ここで\( \left(\frac{a}{n}\right)\)はJacobi記号である。
このとき、\(\mathcal{S}\)は\(\mathbb{Z}_n^*\)の部分群であり、\(n\)が奇数の合成数のとき\(\mathcal{S}\)は\(\mathbb{Z}_n^*\)の真部分群となる。
部分群の位数は、群の位数を割り切る。
よって、\(\mathcal{S}\)が\(\mathbb{Z}_n^*\)の真部分群ならば、少なくとも\(\sharp\mathcal{S}\le\sharp\mathbb{Z}_n^*/2\)が言える。
</p>
<p>余勢を駆って、具体的な平方根を求めるアルゴリズムにも言及しよう。
Legendre記号は平方剰余かを判定できたが、それがどんな数かは分からなかった。
<strong>Tonelli-Shanksのアルゴリズム</strong>(Tonelli-Shanks algorithm)は素数\(p\)を法とする\(a\)の平方根を具体的に求めるアルゴリズムである。
</p>
<p>\(a\)は当然、平方剰余を仮定してよい。
つまり、\(\left(\frac{a}{p}\right)=1\)である。
Eulerの規準()より\(t=(p-1)/2\)と置くと、
\begin{align*}
a^t &\equiv 1 \pmod{p}\\
a^{t+1} &\equiv a \pmod{p}\\
a^{(t+1)/2} &\equiv a^{1/2} \pmod{p}
\end{align*}
となり、求めたい平方根は\(a^{(t+1)/2}\)であることが分かる。
とても簡単に求めてしまったように思えるが、もちろん落とし穴があって、ちょっと考えればすぐに\((t+1)/2\)が整数とならなければ計算できないことに気付く。
それでも、\((t+1)/2\)が整数になる、言い換えれば\(p\equiv3\pmod{4}\)の場合のアルゴリズムは得た。
</p>
<p>この考察を一般化しよう。
\(p-1\)は\(2^s\cdot t\)と書けるとする(ここで\(t\)は奇数)。
\(a^t \equiv D^{-2\mu}\pmod{p}\)を満たす\(D,\mu\)が<strong>与えられたとすれば</strong>、先ほどと同様の議論により、
\begin{align*}
a^t &\equiv D^{-2\mu}\pmod{p}\\
a^tD^{2\mu} &\equiv 1 \pmod{p}\\
a^{t+1}D^{2\mu} &\equiv a \pmod{p}\\
a^{(t+1)/2}D^{\mu} &\equiv a^{1/2} \pmod{p}
\end{align*}
となって\(a\)の平方根は\(a^{(t+1)/2}D^{\mu}\)であることが分かる。
</p>
<p>となれば、次は\(D,\mu\)を求める方法を考えるわけだが、ここでは次が正しいとしてアルゴリズムを与える。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(p\)を奇素数、\(d\in\mathbf{QNR}_p\)とする。
\(p-1=2^s\cdot t\)と書ける(ここで\(t\)は奇数)とし、\(A\equiv a^t\pmod{p},D\equiv d^t\pmod{p}\)と置く。
\(0\le k<s\)について、\((AD^m)^{2^{s-k}}\equiv1\pmod{p}\)ならば、\((AD^m)^{2^{s-(k+1)}}\equiv\pm1\pmod{p}\)である。
特に\(-1\)のとき、\(m'=m+2^k\)とすると、\((AD^{m'})^{2^{s-(k+1)}}\equiv1\pmod{p}\)である。
</div>

<p>\(k=0,m=0\)のとき、\((AD^m)^{2^{s-k}}\equiv1\pmod{p}\)を満たすので、あとは\(k\)を大きくしながら常に1になるように\(m\)を書き換えてやればよい。
最終的に\(AD^m\equiv1\pmod{p}\)を満たす\(m\)が見つかるが、これは\(2\mu\)に他ならない。
</p>
<p>Tonelli-Shanksのアルゴリズムは、任意の奇素数\(p\)で正しく平方根を返すのでを実装するだけでもよいのだが、\(p\equiv3\pmod{4}\)ならもっと簡単な方法があるので、コードの簡潔さは劣るが高速化のためにはそちらを使った方が良い。
</p>
<pre class="prettyprint">import random

from legendre_symbol import legendre_symbol
from split_int import split_int


def tonelli_shanks_algorithm(a: int, p: int) -> int:
    """ Tonelli-Shanksのアルゴリズム。

    x^2 = a mod p
    となるようなxを求める。
    このようなxが存在する場合、x,-xの2つが解となる。

    Args:
        a (int): 整数で、pを法として平方剰余
        p (int): 奇素数

    Returns:
        x (int): x^2 = a mod pを満たすxで、0～p-1の範囲の中で小さい数

    Examples:
        >>> tonelli_shanks_algorithm(2, 7) # 4も解であるが、小さいほうの3を返す
        3
        >>> tonelli_shanks_algorithm(10, 13)
        6
    """
    assert legendre_symbol(a, p) == 1  # aは平方非剰余であり、平方根は存在しない

    res = p % 4
    a %= p
    if res == 3:
        x = pow(a, (p+1)//4, p)
    else:
        while True:  # 法pで平方非剰余なdを見つけるまでループする
            d = random.randrange(2, p)
            if legendre_symbol(d, p) == -1:
                break
        s, t = split_int(p - 1)
        A, D = pow(a, t, p), pow(d, t, p)
        m = 0
        for i in range(1, s):
            if pow(A * pow(D, m, p), pow(2, s-1-i), p) == p - 1:
                m += pow(2, i)
        x = (pow(a, (t+1)//2, p) * pow(D, m//2, p)) % p
    return min(x, -x % p)
</pre>

<p>これは、あくまで素数を法とする平方根を求める方法であることに注意する。
</p>

</body></html>