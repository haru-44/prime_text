<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>first_step</h1>
<p>まずは、素数とは何かをはっきりさせよう。
<strong>素数</strong>(prime)とは、1より大きな整数で、1とそれ自身以外では割り切ることができない数である。
具体的には、\(2,3,5,7,11\ldots\)などがそうである。
</p>
<p>定義をうろ覚えの内は、「1は素数なのか？」と訊かれると戸惑ってしまいがちだが、1は素数ではない。
定義に立ち帰ってみると、<strong>1より大きい</strong>とわざわざ仲間外れにしていることがその根拠だ。
<strong>1を作為的に素数から除外する</strong>のは、後で述べる素因数分解の一意性を説明する上で都合が良いからであるが、ここでモヤっとする初学者が多いことも確かだ。
<strong>定義</strong>(definition)とは、概念に対する単なる「名付け」に過ぎない。
夜空に瞬く、ある星たちを「はくちょう座」と呼ぶことに、何ら物理法則が関与しないように、素数もまた人類が認識しやすいように切り取られた一つの概念に過ぎない。
似ている言葉に<strong>定理</strong>(theorem)があるが、こちらは命題の一種であって、まったく別物である。
</p>
<p>「定義」について理解したところで、どのような数が素数なのか、ということを確認したい。
</p>
<ul>
 <li> \(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47\)は50以下のすべての素数である。
 <li> \(4, 12, 99\)は素数ではない。なぜならば、それぞれ\(2, 3, 11\)で割り切れるからである。
</ul>

<p>素数でない整数を、いちいち「素数ではない整数」などと呼ぶことは不便だ{不便だからこそ、「定義する」という行為が行われるのである。}。
そこで、\(1\)でも素数でもない自然数は<strong>合成数</strong>(composite number)と呼ぶこととする。
</p>
<p><strong>整数</strong>(integer)と<strong>自然数</strong>(natural number)も慣れていないと躓いてしまう。
整数とは\(\ldots,-2,-1,0,1,2,\ldots\)と続く数で、自然数は\(1,2,3,\ldots\)と続く数である{自然数にゼロを含める流儀もあるが、本稿では含めないとする}。
それぞれ、\(\mathbb{Z}\)と\(\mathbb{N}\)という記号で書くこともあるが、記号の氾濫は混乱を招くだろうし、適宜補足するから、一旦読み飛ばしてもいい。
</p>
<p>素数が発明されたのは、数の最小単位としての意味合いがある。
人類は物質の最小単位を夢想し、原子や素粒子を見つけてきたが、同じように、\(1,2,3,4,\ldots\)と続く自然数を掛け算でバラバラにすると、素数が現れる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(1\)以外の正整数{正整数、あるいは非負整数は、その名の通り\(1,2,3,\ldots\)と続く数であり、ゼロを除いたときの自然数と同じだ。混乱を招くが、同じ概念に対して複数の用語があてがわれていることは往々にしてある。}は、因子{「因子」も未定義だが、もう少し後で説明するのでご愛嬌。}の順番の違いを除いて、素数の積としてただ一通りに表すことができる。
</div>

<p>\(15\)は\(3\times5\)という分解しかありえない。
逆に、\(5\)と\(7\)の積は常に\(35\)であって、\(36\)や\(43\)になったりしない。
掛け算を習った小学生なら、証明という概念こそないとはいえ、当たり前に受け入れる内容だろう。
</p>
<p>では、この数の原子はどれほど存在するのか？　原子には周期表が作られたが、素数はカタログにまとめられない。
なぜなら、無数に存在することが紀元前の昔から知られているからだ{その証明は蠱惑的であって、数学者を魅了して止まない。(証明)素数は有限であると仮定する。つまり、最大の素数が\(M\)だとすると素数は\(2,3,\ldots,M\)しかないとする。このとき\(N=2\times3\times\cdots\times{M}+1\)は正整数であるが、いずれの素数でも割り切る事が出来ないから\(N\)も素数。これは素数が有限であるという仮定に反する。よって、素数は無限に存在する。(証明終)}。
素数の数を数える、という試みはそれに遅れること約2000年後、1896年に<strong>素数定理</strong>(Prime number theorem)として証明された。
「\(x\)以下の正整数のうち、素数はだいたい\(x/\ln x\)個ある」というのがその輪郭である。
</p>
<p>それでも、素数について人類が知ることは少ない。
「任意の自然数\(n\)に対して、\(n\)と\(2n\)の間には必ず素数が存在する」(<strong>Bertrand–Chebyshevの定理</strong>, Bertrand–Chebyshev theorem)が、「任意の自然数\(n\)に対して、\(n^2\)と\((n+1)^2\)の間には必ず素数が存在する」かは未だ分かっていない(<strong>Legendre予想</strong>, Legendre's conjecture)。
「初項と公差が互いに素である等差数列には無限に素数が存在する」(<strong>算術級数定理</strong>, theorem on arithmetic progressions)が、複数個の等差数列での場合は未解決だ(<strong>Dickson予想</strong>, Dickson's conjecture)。
<strong>双子素数</strong>(twin prime){\(p\)と\(p+2\)が共に素数であるような\((p,p+2)\)のペアを双子素数と呼ぶ。}が無限に存在するかも、<strong>Sophie Germain素数</strong>(Sophie Germain prime){\(p\)と\(2p+1\)が共に素数であるような\(p\)をSophie Germain素数と呼ぶ。}が無限に存在するかも分かっていない。
</p>
<p>分からないことだらけだということが分かったので、少しずつでも分かることを明らかにしていこう。
素数の定義の中には、「割り切れる」という概念が登場したが、これも改めて定義しよう。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
任意の整数\(a\)と、任意の正整数\(b\)に対して、\(a=bq\)なる整数\(q\)が存在するとき、\(b\)は\(a\)を割り切ると言い、\(b \mid a\)と書き、\(b\)を\(a\)の約数、\(a\)を\(b\)の倍数と呼ぶ。
逆に、このような\(q\)が存在しないとき、\(b \nmid a\)と書く。
</div>

<p>約数は、<strong>因数</strong>(factor)あるいは<strong>因子</strong>とも呼ぶ。
どんな整数でも1と自分自身は約数であるから、これらを<strong>自明な約数</strong>と呼び、それ以外の約数を<strong>非自明な約数</strong>と呼ぶこともある。
特に因数、あるいは因子が素数のとき、<strong>素因数</strong>(prime factor)あるいは<strong>素因子</strong>と呼ぶ{一方で、「素約数」とは言わない。}。
約数と倍数は、小学校で習ったからいいとして、「割り切れる」「割り切れない」の記号は初めて目にする方が多いだろう。
最初の頃はどっちがどっちか分からなくなるが、そのうち慣れる。
例を挙げれば、\(3 \mid 6\)であり、\(3 \nmid 10\)である。
</p>
<p>当たり前のことだが、次のことを改めて確認しておこう{こういう基本的な性質は、疎かにしがちで、最初は読み飛ばしてもよいが、手を動かすことで定義が明瞭に理解できる。}。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
整数\(a,b,c\)について、次が成り立つ。
<ol>
 <li> \(c \mid b\)かつ\(b \mid a\)ならば\(c \mid a\)
 <li> \(b \mid a\)ならば、任意の正整数\(c\)に対して\(bc \mid ac\)
</ol>
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>証明</strong>)\;
<ol>
 <li> 仮定より\(b=cq_c, a=bq_b\)なる整数\(q_a,q_b\)が存在する。よって、\(a=bq_b=cq_cq_b\)となり、整数\(q_bq_c\)が存在するため、\(c \mid a\)を得る。
 <li> 仮定より\(b=aq\)なる整数\(q\)が存在する。両辺に\(c\)を掛けて\(bc=acq\)となるため、\(bc \mid ac\)を得る。
</ol>
</div>

<p>約数を列挙するプログラムを作ることは、もはや「Pythonではそういう書き方ができる」ということを知っているかどうかというだけの問題なので、載せるだけに済ませる。
</p>
<pre class="prettyprint">import operator
from functools import reduce
from itertools import product
from typing import List

from sympy.ntheory import factorint


def divisors(n: int) -> List[int]:
    """ nの約数リストを返す

    Args:
        n (int): 対象の自然数

    Returns:
        list[int]: nの約数のリスト

    Examples:
        >>> divisors(7)
        [1, 7]
        >>> divisors(12)
        [1, 2, 3, 4, 6, 12]
    """
    factors = factorint(n)
    powers = [[pow(p, i) for i in range(e + 1)] for p, e in factors.items()]
    return sorted([reduce(operator.mul, p) for p in product(*powers)])
</pre>

<p>「割り切れる」ことが分かったら、自然に公約数と公倍数の概念に辿り着く。
小学校で習ったものだが、堅苦しく言い換えると次のようになる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
正整数\(a, b, d\)について、\(d \mid a\)かつ\( d \mid b\)であるとき、\(d\)を\(a,b\)の公約数と呼ぶ。
また、正整数\(a, b, l\)について、\(a \mid l\)かつ\(b \mid l\)であるとき、\(l\)を\(a,b\)の公倍数と呼ぶ。
</div>

<p>公約数や公倍数の概念は、整数の範囲に拡張することができるが、ここでは正整数の範囲で考えている。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
\(a,b\)の公約数の中で最大の正整数を最大公約数と呼び、\(\gcd(a,b)\)と書く。
また、\(a,b\)の公倍数の中で最小の正整数を最小公倍数と呼び、\(\mbox{lcm}(a,b)\)と書く。
</div>

<p>\(\gcd(a,b)\)は、単に\((a,b)\)と書かれることも多い。
書く方は記載量が減って楽になるが、ぱっと見2つの数の組と区別が付かないので、「そういう書き方もあるよ」という紹介に留める。
</p>
<p>ところで、最大公約数、最小公倍数はあるのに、<strong>最小</strong>公約数、<strong>最大</strong>公倍数がないのはなぜだろうか？　定義するなら公約数の中で最小の正整数を最小公約数、公倍数の中で最大の正整数を最大公倍数と呼ぶことになるだろうが、いくつかの例で試してみれば分かる通り、最小公約数は常に1、最大公倍数は常に無限大{無限を扱うときには細心の注意を払わないといけないのだが、ここではひたすらに大きくなるというイメージだけで話す。}になってしまう。
そういう<strong>つまらない</strong>用語を定義しても、<strong>嬉しくない</strong>。
だから教科書には最小公約数も最大公倍数も載っていない。
だけれども、そういう疑問を持って自分で手を動かしてみることは重要なので、しっかり<strong>間違った</strong>方が良い。
</p>
<p>さらに、\(\gcd(a,b)=1\)のときを論じることが多いので、特に「互いに素」という名前を付ける。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定義</strong>)
\(a,b\)の最大公約数\(\gcd(a,b)\)が\(1\)のとき、\(a\)と\(b\)は互いに素であるという。
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)\;
<ul>
 <li> \(6\)と\(16\)の公約数は\(1,2\)、公倍数は\(48, 96, \ldots\)。よって、最大公約数\(\gcd(6,16)=2\)、最小公倍数\(\mbox{lcm}(6,16)=48\)。
 <li> \(6\)と\(12\)の公約数は\(1,2,3,6\)、公倍数は\(12, 24, \ldots\)。よって、最大公約数\(\gcd(6,12)=6\)、最小公倍数\(\mbox{lcm}(6,12)=12\)。
 <li> \(5\)と\(7\)の公約数は\(1\)、公倍数は\(35, 70, \ldots\)。よって、最大公約数\(\gcd(5,7)=1\)、最小公倍数\(\mbox{lcm}(5,7)=35\)。
</ul>
</div>

<p>ところで、最大公約数を計算する事は簡単だっただろうか。
最大公約数と最小公倍数それ自体は小学校で習うが、求め方は習わなかった。
雰囲気で数値を推測し、後は頑張るしかなかった。
おそらく他の数式計算のようにシステマティックに行われるのではなく、多分に直観的であったはずだ。
もちろん、コンピュータは「直観」というものを知らない。
コンピュータが最大公約数を求めるためにはどうしたらよいか？　実はその計算方法は、紀元前の昔に知られていて、Euclidの互除法と呼ばれているのである。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(a>b>0\)について、\(\gcd(a,b) = \gcd(a - b, b)\)
</div>

<p>これでどうして最大公約数を求められるのか、一見しただけでは分からない。
余りを求める記号として、\(\%\)を使うことにする。
つまり、「\(a\)を\(b\)で割った余り」は\(a \% b\)と書くことにするのだ。
\(\gcd(a,b)=\gcd(b,a)\)であること、\(\gcd(0,b)=b\)であることを踏まえると、最大公約数は次のように再帰的に計算できる。
\begin{align*}
\gcd(a,b) =
\begin{cases}
b, &\mbox{if } a = 0\\
\gcd(b \% a, a), &\mbox{otherwise}
\end{cases}
\end{align*}
</p>
<p>これをコードに落とすと次のようになる。
</p>
<pre class="prettyprint">def gcd(a: int, b: int) -> int:
    """ Euclidの互除法を用いて、aとbの最大公約数を求める。

    Args:
        a, b (int): 最大公約数を求めたい2つの整数

    Returns:
        g (int): aとbの最大公約数

    Examples:
        >>> gcd(15, 20)
        5
        >>> gcd(3, 7)
        1
    """
    if a == 0:
        return b
    return gcd(b % a, a)
</pre>

<p>さらに、最小公倍数はどうなのかというと、\(ab = \gcd(a,b)\mbox{lcm}(a,b)\)という関係があるため、最大公約数を求めれば、すぐに求められる。
</p>
<pre class="prettyprint">from gcd import gcd


def lcm(a: int, b: int) -> int:
    """ aとbの最小公倍数を求める。

    Args:
        a, b (int): 最小公倍数を求めたい2つの整数

    Returns:
        int : aとbの最小公倍数

    Examples:
        >>> lcm(4, 6)
        12
        >>> lcm(4, 9)
        36
    """
    return a * b // gcd(a, b)
</pre>

<p>Euclidの互除法は更に面白いことも教えてくれる。
少しプログラムを変更することで、が得られる。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
整数\(a,b\)に対して、
\begin{align*}
ax + by = \gcd(a,b)
\end{align*}
を満たすような整数\(x,y\)が存在する。
</div>

<p>しかも、存在を示しただけでなく、具体的な値を得るアルゴリズムでもある。
このアルゴリズムは、<strong>拡張Euclidの互除法</strong>(Extended Euclidean algorithm)と呼ばれる。
\(15x+33y=1\)を満たす整数\(x,y\)は存在しないことが分かるし、拡張Euclidの互除法によると、\(25x+4y=1\)を満たす整数\(x,y\)は\(x=1,y=-6\)であることが分かる。
</p>
<pre class="prettyprint">from typing import Tuple


def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    """ 拡張Euclidの互除法によって、ax + by = gcd(a, b)を満たす整数x,yを求める

    Args:
        a, b (int): 最大公約数を求めたい2つの整数

    Returns:
        g, x, y (int): gはaとbの最大公約数。x,yはax + by = gを満たす整数

    Examples:
        >>> extended_gcd(3, 5)
        (1, 2, -1)
        >>> extended_gcd(25, 4)
        (1, 1, -6)
    """
    if a == 0:
        return b, 0, 1
    g, x, y = extended_gcd(b % a, a)
    assert (b % a) * x + a * y == g  # 左式が常に成り立つ
    q = b // a
    assert (b - q * a) * x + a * y == g  # (b % a) を (b - q * a) に置き換える
    assert a * (y - q * x) + b * x == g  # ax + by = g の形に整理する
    return g, y - q * x, x
</pre>


</body></html>