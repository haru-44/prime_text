<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>miller_rabin</h1>
<p>平方剰余の基本的な事実であるが、改めて確認しよう。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(n\)が素数ならば、\(a^2 \equiv 1 \pmod{n}\)を満たす\(a\)は、\(1\)と\(-1\)に限る。
</div>

<p>普通の整数では経験的に明らかであるが、剰余の世界ではそうではない。
「\(n\)が素数ならば」という前提がある時点で察した方もいるだろうが、\(n\)が合成数の場合はその限りではない。
例えば、\(n=15\)のとき2乗して1になるのは、1, 14(\(\equiv-1\))の他に4,11(\(\equiv-4\))がある。
</p>
<p>\(n\)が素数であったとして話を進めよう。
Fermatの小定理()によれば、\(n\)が素数のとき
\begin{align*}
a^{n-1} \equiv 1 \pmod{n}
\end{align*}
が成り立つ。
この両辺の平方根を取る。
つまり、2乗して\(a^{n-1}\)や\(1\)になる数を考える。
左辺は、指数法則が剰余でも通用するため、\(a^{(n-1)/2}\)である。
右辺は、より\(\pm1\)のどちらかである。
つまり、\(n\)が素数の場合、どんな\(a\)でも次の2つの内、少なくとも1つは満たす。
</p><ul>
 <li> \(a^{(n-1)/2} \equiv 1 \pmod{n}\)
 <li> \(a^{(n-1)/2} \equiv -1 \pmod{n}\)
</ul>

<p>次に、1つ目の\(a^{(n-1)/2} \equiv 1 \pmod{n}\)に着目する。
これも平方根を取ることによって、同じことが言える。
\(a^{(n-1)/2} \equiv 1 \pmod{n}\)になるのは、\(a^{(n-1)/4}\bmod{n}\)が\(1\)または\(-1\)のときである。
</p>
<p>これを繰り返すことによって、直感的には次のように展開していく。
左上がFermatの小定理であり、右側が平方根が\(-1\)の場合、下側が平方根が\(1\)の場合を表している。
\begin{align*}
a^{n-1} &\equiv 1 \pmod{n} \qquad\to\qquad a^{(n-1)/2} \equiv -1 \pmod{n}\\
&\downarrow \\
a^{(n-1)/2} &\equiv 1 \pmod{n} \qquad\to\qquad a^{(n-1)/4} \equiv -1 \pmod{n} \\
&\downarrow \\
a^{(n-1)/4} &\equiv 1 \pmod{n} \qquad\to\qquad a^{(n-1)/8} \equiv -1 \pmod{n} \\
&\downarrow \\
&\vdots
\end{align*}
</p>
<p>こう書くと、無限に続いてしまうように思われるかも知れないが、そうではない。
\(a\)の指数部が奇数のとき、平方根を取ることができなくなって、打ち止めとなるのだ。
具体的な数で試してみると、例えば\(n=29\)のとき、奇数の\(7\)に達した時点で止まる。
\begin{align*}
a^{28} &\equiv 1 \pmod{n} \qquad\to\qquad a^{14} \equiv -1 \pmod{n}\\
&\downarrow \\
a^{14} &\equiv 1 \pmod{n} \qquad\to\qquad a^{7} \equiv -1 \pmod{n} \\
&\downarrow \\
a^{7} &\equiv 1 \pmod{n}
\end{align*}
</p>
<p>これら末端の数式をまとめると、次のような命題が得られる。
</p><div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
\(n=29\)が素数ならば、どんな\(a\)でも次の3つの内、少なくとも1つを満たす。
<ul>
<li> \(a^{14} \equiv -1 \pmod{n}\)
<li> \(a^{7} \equiv -1 \pmod{n}\)
<li> \(a^{7} \equiv 1 \pmod{n}\)
</ul>
</div>

<p>\(n\)に具体的な数値を与えて命題を書き下してみたが、この方法はどんな奇数\(n\)についても適用できることは明らかだ。
一般の\(n\)については次のように書ける。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(m\)を奇数とし、\(n-1 = 2^s \cdot m\)と表現する。
\(n\)が素数ならば、任意の自然数\(a\)(\(0<a<n\))について、次のうち、少なくともどちらか1つは満たす。
<ul>
<li> \(a^m \equiv 1 \pmod{n}\)
<li> ある\(t\)(\(0\le t<s\))が存在して、\(a^{2^tm} \equiv -1 \pmod{n}\)
</ul>
</div>

<p>素数判定法において、対偶を考えることは十八番だ。
この定理の対偶は次のようになり、<strong>Miller-Rabinテスト</strong>(Miller–Rabin primality test)はこの定理を利用する。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>定理</strong>)
\(m\)を奇数とし、\(n-1 = 2^s \cdot m\)と表現する。
次を同時に満たす自然数\(a\)(\(0<a<n\))が存在するならば、\(n\)は合成数である。
<ul>
<li> \(a^m \not\equiv 1 \pmod{n}\)
<li> 任意の\(t\)(\(0\le t<s\))について、\(a^{2^tm} \not\equiv -1 \pmod{n}\)
</ul>
</div>

<p>Miller-Rabinテストもやはり、確率的な素数判定法である。
「合成数」と判定されれば確実に合成数だが、「素数」と判定されても確実ではない。
なぜならば、合成数であるにも関わらずMiller-Rabinテストを突破するような\(a\)が存在するからだ。
例えば、\(n=121=11^2\)にMiller-Rabinテストを実施する場合
</p><ul>
<li> \(a^{60} \equiv -1 \pmod{121}\)
<li> \(a^{30} \equiv -1 \pmod{121}\)
<li> \(a^{15} \equiv -1 \pmod{121}\)
<li> \(a^{15} \equiv 1 \pmod{121}\)
</ul>
<p>の内、少なくとも1つを満たせば「素数」と判定される。
\(a=3\)を選ぶと4つ目の条件
\begin{align*}
3^{15} \equiv 1 \pmod{121}
\end{align*}
を満たし、\(121\)は素数と判定されることになるが、もちろん誤りだ。
しかし、本当の素数と違って、どんな\(a\)についてもテストをパスするわけではない。
実際、\(a=2\)の場合は
</p><ul>
<li> \(a^{60} \equiv 89 \pmod{121}\)
<li> \(a^{30} \equiv 45 \pmod{121}\)
<li> \(a^{15} \equiv 98 \pmod{121}\)
</ul>
<p>となり、確かに合成数と判定される。
なので、「素数」と判定されても安心せず、確実性を上げるために複数回のチェックを行う必要がある。
ただし、\(n\)が十分小さければそのような心配をしなくてもいいかもしれない。
実際、\(n<2047\)の場合は、\(a=2\)のみで確実に素数かを判定できるし、\(n<1373653\)の場合は、\(a=2\)に加えて\(a=3\)でチェックするだけでよい。
となれば、より少ない\(a\)でなるべく大きな\(n\)を確実に素数判定できるような、巧い組み合わせを見つけれれば、嬉しいことになる。
有志による調査の結果が、<a href="https://miller-rabin.appspot.com/">https://miller-rabin.appspot.com/</a>にまとめられているので参考にされたい。
</p>
<p>\Algo{補助関数}{split_int}
</p>
<pre class="prettyprint">import bisect
import random

from split_int import split_int


def miller_rabin_test(n: int, k: int = 10) -> str:
    """ Miller-Rabinテストを用いて、n>2が素数かを判定する。
    nが小さい場合は、既知の底を使って、確定的に素数判定を行う。

    計算量 : O(k |n|^3)

    Args:
        n (int): 素数判定する対象の整数
        k (int): 試行回数。既定値を10としたが、特に意味はない。
                 nが2^64未満なら不使用。
                 合成数だが'probable prime'と判定する確率は高々4^{-k}

    Returns:
        string: 'composite number' = nは合成数
                'prime number'     = nは素数
                'probable prime'   = nはおそらく素数

    Examples:
        >>> miller_rabin_test(101)
        'prime number'
        >>> miller_rabin_test(111)
        'composite number'

    Notes:
        底は次のサイトから取得
        https://miller-rabin.appspot.com/
    """
    s, m = split_int(n - 1)
    deterministic_list = [(341531,             [9345883071009581737]),
                          (1050535501,         [336781006125,
                                                9639812373923155]),
                          (350269456337,       [4230279247111683200,
                                                14694767155120705706,
                                                16641139526367750375]),
                          (55245642489451,     [2,
                                                141889084524735,
                                                1199124725622454117,
                                                11096072698276303650]),
                          (7999252175582851,   [2,
                                                4130806001517,
                                                149795463772692060,
                                                186635894390467037,
                                                3967304179347715805]),
                          (585226005592931977, [2,
                                                123635709730000,
                                                9233062284813009,
                                                43835965440333360,
                                                761179012939631437,
                                                1263739024124850375]),
                          (2**64,              [2,
                                                325,
                                                9375,
                                                28178,
                                                450775,
                                                9780504,
                                                1795265022])]
    idx = bisect.bisect([num for num, _ in deterministic_list], n)
    deterministic = idx < len(deterministic_list)
    if deterministic:
        a_list = deterministic_list[idx][1]
    else:
        a_list = [random.randrange(2, n) for _ in range(k)]
    for a in a_list:
        if pow(a, m, n) != 1 and all(pow(a, 2**t * m, n) != n - 1 for t in range(s)):
            return 'composite number'
    return 'prime number' if deterministic else 'probable prime'
</pre>

<p>では、どのくらいの\(a\)が判定を誤らせるのだろうか。
1回の試行で間違う確率は、高々1/4と評価されている(Solovay-Strassenテストよりも良い)。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>命題</strong>)
奇数の合成数\(n>9\)に対して、Miller-Rabinテストが誤って素数と判定してしまうような\(a\)の個数は、\(\frac{1}{4}\varphi(n)\)以下である。
</div>

<p>そのため、試行回数を増やすことによって、ほぼ確実に素数であることを判定できる。
ゆえに、RSA暗号の鍵生成に際して利用されるなど、広く実用に供されているアルゴリズムでもある。
</p>


</body></html>