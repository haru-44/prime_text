<html lang="ja">
  <head>
    <script type="text/x-mathjax-config">
       MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
  <strong>このページは、pdfファイル出力用に作成したtexファイルから機械的に変換されています。体裁不良がある場合は<a href="https://github.com/haru-44/prime_text/releases/latest/download/main.pdf">pdfファイル</a>をご覧ください。</strong>
  <hr/>
<h1>rho_method</h1>
<p><strong>Pollardの\(\rho\)法</strong>(Pollard's \(\rho\) Algorithm)は、素因数分解アルゴリズムの1つである（以後、単に\(\rho\)法と呼ぶ）。
\(\rho\)法は、関数が\(\rho\)の字の如く、あるときから周期的になるという性質を利用する。
ただし、利用するからと言って、陽に現れるわけではないことに注意したい。
アルゴリズムの実行によって現れる数列には、周期的な見た目はない。
そして我々の目的はあくまで素因数分解することであって、周期を見つけることではないことにも注意しておく。
</p>
<p>\(\rho\)法が高速に素因数を発見できるかは、\(n\)の素因数\(p\)の大きさに拠っている。
もう少し具体的に言えば、実行時間は\(O(\sqrt{p})\)と期待できる。
これは、試し割の\(O(\sqrt{n})\)より平均的には良くなる。
</p>
<p>有限集合\(\mathcal{S}\)と、\(\mathcal{S}\)から\(\mathcal{S}\)への関数\(f:\mathcal{S}\to\mathcal{S}\)について考える。
\(f(s), f(f(s)),\ldots\)と次々に\(f\)を適用すると、どうなっていくだろうか。
</p>
<p>\begin{align*}
s_0 &\in \mathcal{S}\\
s_1 &\gets f(s_0)\\
s_2 &\gets f(s_1)\\
&\vdots
\end{align*}
</p>
<p>\(f(s)=3s^2+1\bmod{11}\)とし、初期値は\(3\)と\(7\)を試そう。
どちらも、途中から\(10\to4\to5\to10\)という周期に至ったことが観察できる。
\begin{table}[htbp] \caption{\(3s^2+1\bmod{11}\)の計算結果}
    \begin{center}
     \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline
      \(s_0\) & \(s_1\) & \(s_2\) & \(s_3\) & \(s_4\) & \(s_5\) & \(s_6\) & \(s_7\) & \(s_8\) \\ \hline
      3     & 6     & 10    & 4     & 5     & 10    & 4     & 5     & 10    \\ \hline
      7     & 5     & 10    & 4     & 5     & 10    & 4     & 5     & 10    \\ \hline
     \end{tabular}
    \end{center}
\end{table}
</p>
<p>一般に、\(f\)を繰り返し適用するといつかは周期になる、ということが言える。
数学的な厳密さは脇に置こう。
最初の一歩はイメージが重要である。
ここから\(\rho\)の字をイメージできるだろうか(別に"9"や"p"でも形としては良いのであるが)。
初期値は\(\rho\)の<strong>尻尾</strong>にあたり、周期が丸い部分にあたる。
しかも、\(f\)がランダムだと仮定すると、尻尾の長さ、周期の長さ共に\(\sqrt{|\mathcal{S}|}\)程度になる。
ここで言う「ランダム」には若干注意が必要で、暗号理論で求められるような「次がどんな値になるのか推測できない」というような「ランダム」までは必要がない。
要は、「誕生日のパラドックス」を成り立たせて、周期の長さを\(\sqrt{|\mathcal{S}|}\)程度だと見積もりたいがための「ランダム」であって、それ以上の意味はない。
</p>
<p>ともかく、\(f\)は繰り返し適用すると、いつかは周期になって\(\rho\)の字を描く。
そしてその長さは\(\sqrt{|\mathcal{S}|}\)程度になる。
これくらい理解すれば次に進める。
関数\(f\)の挙動がこのようになることから、これから紹介するアルゴリズムが\(\rho\)法と名付けられたわけであるが、この事実がどのように素因数分解とつながるかを見ていこう。
</p>
<p>\(n\)を合成数、\(p\)を\(n\)の素因数の1つだとする。
つまり、ある整数\(M\)が存在して、\(n=pM\)と書けるとする。
目的は、\(n\)を素因数分解すること、つまり、\(p\)を見つけ出すことである。
しかし、ここでは知らないはずの\(p\)を<strong>知っている</strong>と仮定して話を進める。
これはマジシャンの後ろから手品を見る行為である。
あるいは、カラクリ人形の内部を覗く行為である。
観客からは摩訶不思議な現象でも、その裏側にある手品のタネは至極単純なものである。
</p>
<p>例えば、\(n=611, p=13,f_p(s)=s^2+1\bmod{p}\)とする。
今は\(p\)を知っているので、\(f_p(s)\)を計算できる。
</p>
<p>\(2\to5\to0\to1\to2\)という周期が見られるため、\(f_p\)は尻尾の長さ0、周期の長さ4であることが分かる。
これ自体は、前節でも解説した通りの\(f\)の性質である。
一方で、\(f_n(s)=s^2+1\bmod{n}\)を\(f_p\)と比べても何か意味のあるようには見えない。
しかし、実際には\(f_n\)と\(f_p\)には密接な関係がある。
関数\(f\)を\(m\)回適用した値を\(f^{(m)}\)と書くことにすれば、周期が存在するとは\(f^{(i)}=f^{(i+l)}\)となるような\(l\)が存在することであり、\(l\)は周期の長さである(尻尾の長さがあることを考慮すれば\(i\)には条件を付けなければならないが、一旦無視する)。
</p>
<p>よって、\(n\)との最大公約数を計算すれば、\(p\)が求められる。
\(p\)の倍数の中には、\(n\)の倍数もあるから、不幸にも、\(f_n^{(i)}-f_n^{(i + l)}\)と\(n\)の最大公約数が\(n\)になることもあり得るが、ここでは一旦脇に置く。
つまり我々は、\(f_p\)を知ることができないが、<strong>周期が4であることのみを教えて貰えることができれば</strong>、\(f_n^{(1)}-f_n^{(5)}=2-80=-78\)が\(p\)の倍数であることが分かる（もちろん、\(f_n^{(2)}-f_n^{(6)}\)や\(f_n^{(3)}-f_n^{(7)}\)でも同じだ）。
</p>
<p>この節での主要部分は、\(f_p\)の周期の長ささえ分かれば\(n\)を素因数分解できるということだ。
しかし、\(f_p\)の周期の長さを求めるには結局\(p\)を知る必要があって、堂々巡りに陥ってしまったのではないか。
これを解決するのが次の目標である。
</p>
<p>実際の素因数分解をする局面では、\(p\)による数列は分からない。
しかるに、周期の長さも知るよしがない。
実際に得られるのは、例えば\(n=611,s=2,f_n=x^2+1\bmod{n}\)とすると、
\begin{align*}
2 \to 5 \to 26 \to 66 \to 80 \to 291 \to 364 \to 521 \to 158 \to 525 \to 65 \to 560 \to 158 \to 525 \to 65
\end{align*}
というような数列である。
</p>
<p>この裏には、\(p\)による周期が隠れているのだが、一体どうすればそれを見つけられるのだろうか。
</p>
<p>一番素朴な方法は、すべての\(0\le{i}<j\le{k}\)で、\(f_n^{(i)}-f_n^{(j)}\)と\(n\)の最大公約数を求めることだ。
周期がどんな値であるかは知らないが、非自明な公約数さえ求められればよいのだから総当たり的に試せばよいという考えだ。
しかし、これでは非効率的だ。
最大公約数を求める回数は、数列の長さの2乗に比例して増えてしまう。
</p>
<p>これを解決するのが、<strong>Floydの周期発見法</strong>(Floyd's cycle-fnding algorithm)である。
\(f\)の尻尾の長さが\(j\)、周期の長さが\(l\)であれば、\(f^{(m)}=f^{(m+l)}=f^{(m+2l)}=\cdots\)が、任意の\(m>{j}\)で成り立つ。
\(m'\)を\(l\)の倍数で、\(j\)を超える最小の数としよう。
すると、\(f^{(m')}=f^{(2m')}\)が成り立つ。
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #000000;">(<strong>例</strong>)
\(f\)の尻尾の長さが\(j = 8\)、周期の長さが\(l = 5\)ならば、\(m' = 10\)となる。\(f^{(10)}=f^{(20)}\)は正しい。
</div>

<p>これで、周期発見問題は、\(m'\)発見問題にすり替わった。
\(m'\)を発見するには、候補を\(1\)から順番に試してみれば良い。
つまり、\(\gcd(f^{(i)}(s) - f^{(2i)}(s), n)\) (\(i=1,2,\ldots\))を計算すれば、非自明な約数を見つけることができる。
</p>
<p>以上のことを実装してみよう。
関数には\(f(x)=x^k+a\)を使い、初期値は\(s\)とする。
ここでは、\(a, s\)について、考察する。
\(k\)についての考察は次項に行うが、基本的には\(2\)でよい。
</p>
<p>実装上、\(\gcd(f^{(i)}(s) - f^{(2i)}(s), n)\)はそのままではない。
\begin{align*}
u &= f(u)\\
v &= f(f(v))
\end{align*}
とすることで、\(u\)は1ずつカウントアップすることになり、一方\(v\)は2ずつカウントアップすることになる。
</p>
<pre class="prettyprint">import math


def pollard_rho_algorithm(n: int, k: int = 2, a: int = 1, s: int = 1) -> int:
    """ Pollardのρ法を用いて、nの非自明な約数を見つける。

    パラメータa, sは、1～n-1の任意の値。通常はランダムに決めて良い。
    パラメータkは、通常2を使用する。

    Args:
        n (int): 素因数分解する対象の自然数
        k, a (int): 使用するランダム関数。
                    f(x) = x^k + a
        s (int): 関数の初期値

    Returns:
        divisor (int): nの非自明な約数。発見できないときは、1

    Examples:
        >>> pollard_rho_algorithm(323) # 323 = 17 * 19
        19
    """
    u = v = s
    def _func(x):
        return (pow(x, k, n) + a) % n
    while True:
        u = _func(u)
        v = _func(_func(v))
        divisor = math.gcd(u - v, n)
        if divisor == n:
            # a, sが良くなかったか、nは素数
            return 1
        if divisor != 1:
            return divisor
</pre>


</body></html>